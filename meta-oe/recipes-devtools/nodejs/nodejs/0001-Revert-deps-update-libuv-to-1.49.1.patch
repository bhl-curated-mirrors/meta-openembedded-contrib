From bcaa6f84cf6e64e0f7bb60a2c194aa5dc79a10ea Mon Sep 17 00:00:00 2001
From: Martin Jansa <martin.jansa@gmail.com>
Date: Wed, 11 Dec 2024 11:29:08 +0100
Subject: [PATCH] Revert "deps: update libuv to 1.49.1"

This reverts commit 41c50bc15e36836538ccbe54f00de5658b4cafa8.

Upstream-Status: Pending

Signed-off-by: Martin Jansa <martin.jansa@gmail.com>
---
 deps/uv/.mailmap                   |   7 +-
 deps/uv/AUTHORS                    |  21 --
 deps/uv/CMakeLists.txt             |  29 +--
 deps/uv/ChangeLog                  | 241 +------------------
 deps/uv/Makefile.am                |   4 -
 deps/uv/README.md                  |  12 -
 deps/uv/configure.ac               |   2 +-
 deps/uv/include/uv.h               |  62 ++---
 deps/uv/include/uv/tree.h          | 253 +++++++++++++++++++-
 deps/uv/include/uv/version.h       |   4 +-
 deps/uv/include/uv/win.h           |   4 +-
 deps/uv/src/random.c               |   2 +-
 deps/uv/src/threadpool.c           |   2 +-
 deps/uv/src/unix/async.c           | 132 ++--------
 deps/uv/src/unix/core.c            | 171 ++-----------
 deps/uv/src/unix/cygwin.c          |  40 +---
 deps/uv/src/unix/darwin-syscalls.h |  17 --
 deps/uv/src/unix/darwin.c          |   8 +-
 deps/uv/src/unix/freebsd.c         |   7 +-
 deps/uv/src/unix/fs.c              | 190 ++-------------
 deps/uv/src/unix/fsevents.c        |  13 +-
 deps/uv/src/unix/getaddrinfo.c     |   2 +-
 deps/uv/src/unix/getnameinfo.c     |   2 +-
 deps/uv/src/unix/internal.h        |  60 +----
 deps/uv/src/unix/kqueue.c          |  44 ----
 deps/uv/src/unix/linux.c           | 371 +++++++++--------------------
 deps/uv/src/unix/loop.c            |   8 -
 deps/uv/src/unix/pipe.c            |  39 +--
 deps/uv/src/unix/process.c         |   9 +-
 deps/uv/src/unix/signal.c          |   2 +-
 deps/uv/src/unix/stream.c          |  45 ++--
 deps/uv/src/unix/tcp.c             |  42 +---
 deps/uv/src/unix/tty.c             |  33 +--
 deps/uv/src/unix/udp.c             | 193 ++++++---------
 deps/uv/src/uv-common.h            |   8 +-
 deps/uv/src/win/error.c            |  12 +-
 deps/uv/src/win/fs-event.c         |  20 +-
 deps/uv/src/win/fs.c               | 309 +++++++-----------------
 deps/uv/src/win/getaddrinfo.c      | 126 +++++-----
 deps/uv/src/win/getnameinfo.c      |   4 +-
 deps/uv/src/win/internal.h         |   2 -
 deps/uv/src/win/pipe.c             | 267 +++++++++------------
 deps/uv/src/win/process-stdio.c    |  35 ++-
 deps/uv/src/win/process.c          |  75 +++---
 deps/uv/src/win/req-inl.h          |  10 +-
 deps/uv/src/win/signal.c           |   2 +-
 deps/uv/src/win/stream.c           |   6 +-
 deps/uv/src/win/tcp.c              |  45 ++--
 deps/uv/src/win/thread.c           |  44 +++-
 deps/uv/src/win/tty.c              |   8 +-
 deps/uv/src/win/udp.c              |  12 +-
 deps/uv/src/win/util.c             |  90 +++----
 deps/uv/src/win/winapi.c           |  12 +-
 deps/uv/src/win/winapi.h           |  61 -----
 deps/uv/uv.gyp                     |   1 -
 55 files changed, 1031 insertions(+), 2189 deletions(-)
 delete mode 100644 deps/uv/src/unix/darwin-syscalls.h

diff --git a/deps/uv/.mailmap b/deps/uv/.mailmap
index 97f5d1f2c00..bf12432495d 100644
--- a/deps/uv/.mailmap
+++ b/deps/uv/.mailmap
@@ -4,7 +4,6 @@ Aaron Bieber <qbit@deftly.net> <deftly@gmail.com>
 Alan Gutierrez <alan@prettyrobots.com> <alan@blogometer.com>
 Andrius Bentkus <andrius.bentkus@gmail.com> <toxedvirus@gmail.com>
 Andy Fiddaman <andy@omniosce.org> <omnios@citrus-it.co.uk>
-Andy Pan <panjf2000@gmail.com> <i@andypan.me>
 Bert Belder <bertbelder@gmail.com> <i@bertbelder.com>
 Bert Belder <bertbelder@gmail.com> <info@2bs.nl>
 Bert Belder <bertbelder@gmail.com> <user@ChrUbuntu.(none)>
@@ -19,7 +18,6 @@ David Carlier <devnexen@gmail.com>
 Devchandra Meetei Leishangthem <dlmeetei@gmail.com>
 Fedor Indutny <fedor.indutny@gmail.com> <fedor@indutny.com>
 Frank Denis <github@pureftpd.org>
-Hüseyin Açacak <110401522+huseyinacacak-janea@users.noreply.github.com> <huseyin@janeasystems.com>
 Imran Iqbal <imrani@ca.ibm.com> <imran@imraniqbal.org>
 Isaac Z. Schlueter <i@izs.me>
 Jason Williams <necmon@yahoo.com>
@@ -39,7 +37,6 @@ Michael Neumann <mneumann@think.localnet> <mneumann@ntecs.de>
 Michael Penick <michael.penick@datastax.com> <mpenick@users.noreply.github.com>
 Nicholas Vavilov <vvnicholas@gmail.com>
 Nick Logan <ugexe@cpan.org> <nlogan@gmail.com>
-Olivier Valentin <ovalenti@redhat.com> <valentio@free.fr>
 Rasmus Christian Pedersen <zerhacken@yahoo.com>
 Rasmus Christian Pedersen <zerhacken@yahoo.com> <ruysch@outlook.com>
 Richard Lau <rlau@redhat.com> <riclau@uk.ibm.com>
@@ -50,8 +47,8 @@ Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 Sam Roberts <vieuxtech@gmail.com> <sam@strongloop.com>
 San-Tai Hsu <vanilla@fatpipi.com>
 Santiago Gimeno <santiago.gimeno@quantion.es> <santiago.gimeno@gmail.com>
-Saúl Ibarra Corretgé <s@saghul.net>
-Saúl Ibarra Corretgé <s@saghul.net> <saghul@gmail.com>
+Saúl Ibarra Corretgé <saghul@gmail.com>
+Saúl Ibarra Corretgé <saghul@gmail.com> <s@saghul.net>
 Shigeki Ohtsu <ohtsu@iij.ad.jp> <ohtsu@ohtsu.org>
 Shuowang (Wayne) Zhang <shuowang.zhang@ibm.com>
 TK-one <tk5641@naver.com>
diff --git a/deps/uv/AUTHORS b/deps/uv/AUTHORS
index 807440b30e8..f3942ced3c5 100644
--- a/deps/uv/AUTHORS
+++ b/deps/uv/AUTHORS
@@ -567,24 +567,3 @@ Ardi Nugraha <33378542+ardi-nugraha@users.noreply.github.com>
 Anton Bachin <antonbachin@yahoo.com>
 Trevor Flynn <trevorflynn@liquidcrystalstudios.com>
 Andy Pan <panjf2000@gmail.com>
-Viacheslav Muravyev <slavamuravey@mail.ru>
-Anthony Alayo <anthony.alayo@gmail.com>
-Thomas Walter <31201229+waltoss@users.noreply.github.com>
-hiiizxf <385122613@qq.com>
-Geddy <guandichao@163.com>
-Farzin Monsef <monseffarzin@gmail.com>
-tgolang <154592711+tgolang@users.noreply.github.com>
-josedelinux <josedelinux@hotmail.com>
-Hüseyin Açacak <110401522+huseyinacacak-janea@users.noreply.github.com>
-Uilian Ries <uilianries@gmail.com>
-Olivier Valentin <ovalenti@redhat.com>
-郑苏波 (Super Zheng) <superzheng@tencent.com>
-zeertzjq <zeertzjq@outlook.com>
-Ian Butterworth <i.r.butterworth@gmail.com>
-握猫猫 <164346864@qq.com>
-Zuohui Yang <274048862@qq.com>
-Edigleysson Silva (Edy) <edigleyssonsilva@gmail.com>
-Raihaan Shouhell <raihaanhimself@gmail.com>
-Rialbat <miha-wead@mail.ru>
-Adam <adam@NetBSD.org>
-Poul T Lomholt <ptlomholt@users.noreply.github.com>
diff --git a/deps/uv/CMakeLists.txt b/deps/uv/CMakeLists.txt
index 28c6df25666..5e8e0166d74 100644
--- a/deps/uv/CMakeLists.txt
+++ b/deps/uv/CMakeLists.txt
@@ -81,20 +81,15 @@ if(TSAN)
 endif()
 
 if(UBSAN)
-  cmake_minimum_required(VERSION 3.13)
   list(APPEND uv_defines __UBSAN__=1)
   if(CMAKE_C_COMPILER_ID MATCHES "AppleClang|GNU|Clang")
-    add_compile_options("-fsanitize=undefined" "-fno-sanitize-recover=undefined")
-    if (NOT WIN32)
-      add_link_options("-fsanitize=undefined")
-    endif()
-    if(MSVC)
-      add_compile_options("/Oy-")
-    else()
-      add_compile_options("-fno-omit-frame-pointer")
-    endif()
+    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-omit-frame-pointer -fsanitize=undefined")
+    set (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fno-omit-frame-pointer -fsanitize=undefined")
+    set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fno-omit-frame-pointer -fsanitize=undefined")
+  elseif(MSVC)
+    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /fsanitize=undefined")
   else()
-    message(SEND_ERROR "UndefinedBehaviorSanitizer support requires clang or gcc. Try again with -DCMAKE_C_COMPILER.")
+    message(SEND_ERROR "UndefinedBehaviorSanitizer support requires clang, gcc, or msvc. Try again with -DCMAKE_C_COMPILER.")
   endif()
 endif()
 
@@ -312,7 +307,6 @@ if(APPLE)
 endif()
 
 if(CMAKE_SYSTEM_NAME STREQUAL "GNU")
-  list(APPEND uv_defines _GNU_SOURCE _POSIX_C_SOURCE=200112 _XOPEN_SOURCE=500)
   list(APPEND uv_libraries dl)
   list(APPEND uv_sources
        src/unix/bsd-ifaddrs.c
@@ -572,7 +566,6 @@ if(LIBUV_BUILD_TESTS)
        test/test-hrtime.c
        test/test-idle.c
        test/test-idna.c
-       test/test-iouring-pollhup.c
        test/test-ip4-addr.c
        test/test-ip6-addr.c
        test/test-ip-name.c
@@ -650,7 +643,6 @@ if(LIBUV_BUILD_TESTS)
        test/test-tcp-oob.c
        test/test-tcp-open.c
        test/test-tcp-read-stop.c
-       test/test-tcp-reuseport.c
        test/test-tcp-read-stop-start.c
        test/test-tcp-rst.c
        test/test-tcp-shutdown-after-write.c
@@ -699,7 +691,6 @@ if(LIBUV_BUILD_TESTS)
        test/test-udp-send-unreachable.c
        test/test-udp-try-send.c
        test/test-udp-recv-in-a-row.c
-       test/test-udp-reuseport.c
        test/test-uname.c
        test/test-walk-handles.c
        test/test-watcher-cross-stop.c)
@@ -796,14 +787,6 @@ if(MSVC)
   endif()
 endif()
 
-if(BUILD_SHARED_LIBS)
-  set(LIB_SELECTED uv)
-else()
-  set(LIB_SELECTED uv_a)
-endif()
-
-add_library(libuv::libuv ALIAS ${LIB_SELECTED})
-
 message(STATUS "summary of build options:
     Install prefix:  ${CMAKE_INSTALL_PREFIX}
     Target system:   ${CMAKE_SYSTEM_NAME}
diff --git a/deps/uv/ChangeLog b/deps/uv/ChangeLog
index e1d1aa32989..05c1cb7e748 100644
--- a/deps/uv/ChangeLog
+++ b/deps/uv/ChangeLog
@@ -1,237 +1,4 @@
-2024.10.11, Version 1.49.1 (Stable)
-
-Changes since version 1.49.0:
-
-* build: add darwin-syscalls.h to release tarball (Ben Noordhuis)
-
-* linux: use IORING_SETUP_NO_SQARRAY when available (Ben Noordhuis)
-
-* linux: use IORING_OP_FTRUNCATE when available (Ben Noordhuis)
-
-* win: fix pNtQueryDirectoryFile check (Rialbat)
-
-* win: fix WriteFile() error translation (Santiago Gimeno)
-
-* win,fs: uv_fs_rmdir() to return ENOENT on file (Santiago Gimeno)
-
-* win,pipe: ipc code does not support async read (Jameson Nash)
-
-* netbsd: fix build (Adam)
-
-* win,fs: fix bug in fs__readdir (Hüseyin Açacak)
-
-* unix: workaround gcc bug on armv7 (Santiago Gimeno)
-
-* unix: work around arm-linux-gnueabihf-gcc bug (Ben Noordhuis)
-
-* unix: fix uv_tcp_keepalive in smartOS (Santiago Gimeno)
-
-* unix: fix uv_getrusage ru_maxrss on solaris (Poul T Lomholt)
-
-
-2024.09.25, Version 1.49.0 (Stable), d2e56a5e8d3e39947b78405ca6e4727c70f5568a
-
-Changes since version 1.48.0:
-
-* test: fix -Wpointer-to-int-cast on 32 bits systems (Ben Noordhuis)
-
-* build: add alias for libuv to CMakeLists.txt (Anthony Alayo)
-
-* linux: create io_uring sqpoll ring lazily (Ben Noordhuis)
-
-* misc: run sample CI when code changes (Jameson Nash)
-
-* linux: fix uv_available_parallelism using cgroup (Thomas Walter)
-
-* doc: fix tty example segfault (hiiizxf)
-
-* udp,unix: fix sendmsg use-after-free (Geddy)
-
-* cygwin: implement uv_resident_set_memory (Farzin Monsef)
-
-* win: almost fix race detecting ESRCH in uv_kill (Santiago Gimeno)
-
-* test: disable env var test under win32+asan (Ben Noordhuis)
-
-* unix,fs: fix realpath calls that use the system allocator (Saúl Ibarra
-  Corretgé)
-
-* sunos: sync tcp keep-alive with other unices (Andy Pan)
-
-* linux: fix /proc/self/stat executable name parsing (Farzin Monsef)
-
-* test,ci: fix [AM]San, disable ASLR (Ben Noordhuis)
-
-* win: remove _alloca usage (Ben Noordhuis)
-
-* unix: reinstate preadv/pwritev fallback code (Ben Noordhuis)
-
-* linux: don't delay EPOLL_CTL_DEL operations (Ben Noordhuis)
-
-* doc: fix typos in ChangeLog (tgolang)
-
-* unix,win: error on zero delay tcp keepalive (Saúl Ibarra Corretgé)
-
-* win: simplify uv_once implementation (Saúl Ibarra Corretgé)
-
-* doc: correct udp socket options documentation (Ben Noordhuis)
-
-* linux: don't use sendmmsg() for single datagrams (Ben Noordhuis)
-
-* unix: fix fd leaks in SCM_RIGHTS error path (Ben Noordhuis)
-
-* win: robustify uv_os_getenv() error checking (Ben Noordhuis)
-
-* test: use newer ASSERT_MEM_EQ macro (Ben Noordhuis)
-
-* unix: de-duplicate conditions for using kqueue (Brad King)
-
-* darwin: simplify uv_hrtime (Saúl Ibarra Corretgé)
-
-* mailmap: update saghul's main email address (Saúl Ibarra Corretgé)
-
-* win: remove no longer needed define (Saúl Ibarra Corretgé)
-
-* doc: fix some typos (josedelinux)
-
-* linux,darwin: make `uv_fs_copyfile` behaves like `cp -r` (Juan José Arboleda)
-
-* dragonfly: disable SO_REUSEPORT for UDP socket bindings (Andy Pan)
-
-* test: remove the obsolete HAVE_KQUEUE macro (Andy Pan)
-
-* unix: use the presence of SOCK_* instead of OS macros for socketpair (Andy
-  Pan)
-
-* bsd: support pipe2() on *BSD (Andy Pan)
-
-* unix: support SO_REUSEPORT with load balancing for TCP (Andy Pan)
-
-* doc: add entries for extended getpw (Juan José Arboleda)
-
-* test: fix the flaky test-tcp-reuseport (Andy Pan)
-
-* aix,ibmi: fix compilation errors in fs_copyfile (Jeffrey H. Johnson)
-
-* unix: support SO_REUSEPORT with load balancing for UDP (Andy Pan)
-
-* tcpkeepalive: distinguish OS versions and use proper time units (Andy Pan)
-
-* win: map ERROR_BAD_EXE_FORMAT to UV_EFTYPE (Hüseyin Açacak)
-
-* doc: add instruction how to install with Conan (Uilian Ries)
-
-* unix,win: remove unused req parameter from macros (Viacheslav Muravyev)
-
-* build: fix android ci build (Ben Noordhuis)
-
-* unix,win: export wtf8 functions properly (Ben Noordhuis)
-
-* hurd: add includes and macro prerequisites (Olivier Valentin)
-
-* hurd: stub uv_thread_setpriority() (Olivier Valentin)
-
-* ci: use macOS 12 for macOS and iOS builds (Saúl Ibarra Corretgé)
-
-* darwin: fix crash on iOS(arm64) (郑苏波 (Super Zheng))
-
-* Create dependabot.yml for updating github-actions (Jameson Nash)
-
-* doc: correct names of Win32 APIs in fs.rst (zeertzjq)
-
-* ci: bump upload and download-artifact versions (dependabot[bot])
-
-* ci: bump actions/setup-python from 4 to 5 (dependabot[bot])
-
-* ci: bump KyleMayes/install-llvm-action from 1 to 2 (dependabot[bot])
-
-* win,error: remap ERROR_NO_DATA to EAGAIN (Jameson Nash)
-
-* test: handle zero-length udp datagram (Ben Noordhuis)
-
-* misc: remove splay trees macros (Viacheslav Muravyev)
-
-* test,openbsd: remove superfluous ifdef guard (Ben Noordhuis)
-
-* win,fs: use posix delete semantics, if supported (Ian Butterworth)
-
-* win: fix env var in uv_os_homedir and uv_os_tmpdir (Hüseyin Açacak)
-
-* fsevents: detect watched directory removal (Santiago Gimeno)
-
-* ci: bump actions/checkout to 4 (dependabot[bot])
-
-* linux: eliminate a read on eventfd per wakeup (Andy Pan)
-
-* test: pipe_overlong_path handle ENAMETOOLONG (Abdirahim Musse)
-
-* win,fs: use the new Windows fast stat API (Hüseyin Açacak)
-
-* win,pipe: fix race with concurrent readers (Jameson Nash)
-
-* win,signal: fix data race dispatching SIGWINCH (Jameson Nash)
-
-* build: ubsan fixes (Matheus Izvekov)
-
-* linux: disable SQPOLL io_uring by default (Santiago Gimeno)
-
-* win: fix fs.c ubsan failure (Matheus Izvekov)
-
-* test: rmdir can return `EEXIST` or `ENOTEMPTY` (Richard Lau)
-
-* test: check for `UV_CHANGE` or `UV_RENAME` event (Richard Lau)
-
-* unix,fs: silence -Wunused-result warning (Santiago Gimeno)
-
-* linux: support abstract unix socket autobinding (Ben Noordhuis)
-
-* kqueue: use EVFILT_USER for async if available (Andy Pan)
-
-* win: remove deprecated GetVersionExW call (Shelley Vohr)
-
-* doc: document uv_loop_option (握猫猫)
-
-* doc: fix the `uv_*_set_data` series of functions (握猫猫)
-
-* doc: properly label enumerations and types (握猫猫)
-
-* doc: document specific macOS fs_event behavior (Santiago Gimeno)
-
-* win,pipe: restore fallback handling for blocking pipes (Jameson Nash)
-
-* unix,win: remove unused rb-tree macro parameters (Viacheslav Muravyev)
-
-* win: compute parallelism from process cpu affinity (Ben Noordhuis)
-
-* win: use NtQueryInformationProcess in uv_os_getppid (Zuohui Yang)
-
-* win,pipe: fix missing assignment to success (Jameson Nash)
-
-* win: fix uv_available_parallelism on win32 (Ben Noordhuis)
-
-* win,pipe: fix another missing assignment to success (Jameson Nash)
-
-* kqueue: disallow ill-suited file descriptor kinds (Andy Pan)
-
-* unix: restore tty attributes on handle close (Ben Noordhuis)
-
-* test: delete test with invalid assumption (Ben Noordhuis)
-
-* dragonflybsd: fix compilation failure (Jeffrey H. Johnson)
-
-* test: run android tests on ci (Edigleysson Silva (Edy))
-
-* darwin: add udp mmsg support (Raihaan Shouhell)
-
-* unix: work around arm-linux-gnueabihf-gcc bug (Ben Noordhuis)
-
-* unix: expand uv_available_parallelism() to support more platforms (Ondřej
-  Surý)
-
-* doc: add known issue in armv7 (Santiago Gimeno)
-
-
-2024.02.07, Version 1.48.0 (Stable), e9f29cb984231524e3931aa0ae2c5dae1a32884e
+2024.02.07, Version 1.48.0 (Stable)
 
 Changes since version 1.47.0:
 
@@ -1144,7 +911,7 @@ Changes since version 1.41.0:
 
 * zos: treat __rfim_utok as binary (Shuowang (Wayne) Zhang)
 
-* zos: use execvpe() to set environ explicitly (Shuowang (Wayne) Zhang)
+* zos: use execvpe() to set environ explictly (Shuowang (Wayne) Zhang)
 
 * zos: use custom proctitle implementation (Shuowang (Wayne) Zhang)
 
@@ -3650,7 +3417,7 @@ Changes since version 1.9.1:
 
 * zos: implement uv__io_check_fd (John Barboza)
 
-* unix: unnecessary use const qualifier in container_of (John Barboza)
+* unix: unneccessary use const qualifier in container_of (John Barboza)
 
 * win,tty: add support for ANSI codes in win10 v1511 (Imran Iqbal)
 
@@ -5753,7 +5520,7 @@ Changes since version 0.11.8:
   is an int64_t, and no longer an int. (Bert Belder)
 
 * process: make uv_spawn() return some types of errors immediately on windows,
-  instead of passing the error code the exit callback. This brings it on
+  instead of passing the error code the the exit callback. This brings it on
   par with libuv's behavior on unix. (Bert Belder)
 
 
diff --git a/deps/uv/Makefile.am b/deps/uv/Makefile.am
index f85a41316c8..a14228da3bf 100644
--- a/deps/uv/Makefile.am
+++ b/deps/uv/Makefile.am
@@ -198,7 +198,6 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-hrtime.c \
                          test/test-idle.c \
                          test/test-idna.c \
-                         test/test-iouring-pollhup.c \
                          test/test-ip4-addr.c \
                          test/test-ip6-addr.c \
                          test/test-ip-name.c \
@@ -276,7 +275,6 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-tcp-flags.c \
                          test/test-tcp-open.c \
                          test/test-tcp-read-stop.c \
-                         test/test-tcp-reuseport.c \
                          test/test-tcp-read-stop-start.c \
                          test/test-tcp-rst.c \
                          test/test-tcp-shutdown-after-write.c \
@@ -326,7 +324,6 @@ test_run_tests_SOURCES = test/blackhole-server.c \
                          test/test-udp-send-unreachable.c \
                          test/test-udp-try-send.c \
                          test/test-udp-recv-in-a-row.c \
-                         test/test-udp-reuseport.c \
                          test/test-uname.c \
                          test/test-walk-handles.c \
                          test/test-watcher-cross-stop.c
@@ -430,7 +427,6 @@ libuv_la_CFLAGS += -D_DARWIN_UNLIMITED_SELECT=1
 libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \
                     src/unix/darwin-proctitle.c \
                     src/unix/darwin-stub.h \
-                    src/unix/darwin-syscalls.h \
                     src/unix/darwin.c \
                     src/unix/fsevents.c \
                     src/unix/kqueue.c \
diff --git a/deps/uv/README.md b/deps/uv/README.md
index 12c3061a894..09e9bf10b6d 100644
--- a/deps/uv/README.md
+++ b/deps/uv/README.md
@@ -232,18 +232,6 @@ $ ./bootstrap-vcpkg.sh # for bash
 $ ./vcpkg install libuv
 ```
 
-### Install with Conan
-
-You can install pre-built binaries for libuv or build it from source using [Conan](https://conan.io/). Use the following command:
-
-```bash
-conan install --requires="libuv/[*]" --build=missing
-```
-
-The libuv Conan recipe is kept up to date by Conan maintainers and community contributors.
-If the version is out of date, please [create an issue or pull request](https://github.com/conan-io/conan-center-index) on the ConanCenterIndex repository.
-
-
 ### Running tests
 
 Some tests are timing sensitive. Relaxing test timeouts may be necessary
diff --git a/deps/uv/configure.ac b/deps/uv/configure.ac
index e3ee8a840c6..d4cc003e343 100644
--- a/deps/uv/configure.ac
+++ b/deps/uv/configure.ac
@@ -13,7 +13,7 @@
 # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
 AC_PREREQ(2.57)
-AC_INIT([libuv], [1.49.1], [https://github.com/libuv/libuv/issues])
+AC_INIT([libuv], [1.48.0], [https://github.com/libuv/libuv/issues])
 AC_CONFIG_MACRO_DIR([m4])
 m4_include([m4/libuv-extra-automake-flags.m4])
 m4_include([m4/as_case.m4])
diff --git a/deps/uv/include/uv.h b/deps/uv/include/uv.h
index 9e450c5110f..a62b3fa69b1 100644
--- a/deps/uv/include/uv.h
+++ b/deps/uv/include/uv.h
@@ -260,9 +260,7 @@ typedef struct uv_metrics_s uv_metrics_t;
 
 typedef enum {
   UV_LOOP_BLOCK_SIGNAL = 0,
-  UV_METRICS_IDLE_TIME,
-  UV_LOOP_USE_IO_URING_SQPOLL
-#define UV_LOOP_USE_IO_URING_SQPOLL UV_LOOP_USE_IO_URING_SQPOLL
+  UV_METRICS_IDLE_TIME
 } uv_loop_option;
 
 typedef enum {
@@ -606,18 +604,7 @@ UV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);
 
 enum uv_tcp_flags {
   /* Used with uv_tcp_bind, when an IPv6 address is used. */
-  UV_TCP_IPV6ONLY = 1,
-
-  /* Enable SO_REUSEPORT socket option when binding the handle.
-   * This allows completely duplicate bindings by multiple processes
-   * or threads if they all set SO_REUSEPORT before binding the port.
-   * Incoming connections are distributed across the participating
-   * listener sockets.
-   *
-   * This flag is available only on Linux 3.9+, DragonFlyBSD 3.6+,
-   * FreeBSD 12.0+, Solaris 11.4, and AIX 7.2.5+ for now.
-   */
-  UV_TCP_REUSEPORT = 2,
+  UV_TCP_IPV6ONLY = 1
 };
 
 UV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,
@@ -658,13 +645,10 @@ enum uv_udp_flags {
   UV_UDP_PARTIAL = 2,
   /*
    * Indicates if SO_REUSEADDR will be set when binding the handle.
-   * This sets the SO_REUSEPORT socket flag on the BSDs (except for
-   * DragonFlyBSD), OS X, and other platforms where SO_REUSEPORTs don't
-   * have the capability of load balancing, as the opposite of what
-   * UV_UDP_REUSEPORT would do. On other Unix platforms, it sets the
-   * SO_REUSEADDR flag. What that means is that multiple threads or
-   * processes can bind to the same address without error (provided
-   * they all set the flag) but only the last one to bind will receive
+   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other
+   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that
+   * multiple threads or processes can bind to the same address without error
+   * (provided they all set the flag) but only the last one to bind will receive
    * any traffic, in effect "stealing" the port from the previous listener.
    */
   UV_UDP_REUSEADDR = 4,
@@ -687,18 +671,6 @@ enum uv_udp_flags {
    * This flag is no-op on platforms other than Linux.
    */
   UV_UDP_LINUX_RECVERR = 32,
-  /*
-   * Indicates if SO_REUSEPORT will be set when binding the handle.
-   * This sets the SO_REUSEPORT socket option on supported platforms.
-   * Unlike UV_UDP_REUSEADDR, this flag will make multiple threads or
-   * processes that are binding to the same address and port "share"
-   * the port, which means incoming datagrams are distributed across
-   * the receiving sockets among threads or processes.
-   *
-   * This flag is available only on Linux 3.9+, DragonFlyBSD 3.6+,
-   * FreeBSD 12.0+, Solaris 11.4, and AIX 7.2.5+ for now.
-   */
-  UV_UDP_REUSEPORT = 64,
   /*
    * Indicates that recvmmsg should be used, if available.
    */
@@ -1931,17 +1903,17 @@ struct uv_loop_s {
 UV_EXTERN void* uv_loop_get_data(const uv_loop_t*);
 UV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);
 
-/* Unicode utilities needed for dealing with Windows. */
-UV_EXTERN size_t uv_utf16_length_as_wtf8(const uint16_t* utf16,
-                                         ssize_t utf16_len);
-UV_EXTERN int uv_utf16_to_wtf8(const uint16_t* utf16,
-                               ssize_t utf16_len,
-                               char** wtf8_ptr,
-                               size_t* wtf8_len_ptr);
-UV_EXTERN ssize_t uv_wtf8_length_as_utf16(const char* wtf8);
-UV_EXTERN void uv_wtf8_to_utf16(const char* wtf8,
-                                uint16_t* utf16,
-                                size_t utf16_len);
+/* String utilities needed internally for dealing with Windows. */
+size_t uv_utf16_length_as_wtf8(const uint16_t* utf16,
+                               ssize_t utf16_len);
+int uv_utf16_to_wtf8(const uint16_t* utf16,
+                     ssize_t utf16_len,
+                     char** wtf8_ptr,
+                     size_t* wtf8_len_ptr);
+ssize_t uv_wtf8_length_as_utf16(const char* wtf8);
+void uv_wtf8_to_utf16(const char* wtf8,
+                      uint16_t* utf16,
+                      size_t utf16_len);
 
 /* Don't export the private CPP symbols. */
 #undef UV_HANDLE_TYPE_PRIVATE
diff --git a/deps/uv/include/uv/tree.h b/deps/uv/include/uv/tree.h
index 06bba084f38..2b28835fded 100644
--- a/deps/uv/include/uv/tree.h
+++ b/deps/uv/include/uv/tree.h
@@ -35,7 +35,21 @@
 #endif
 
 /*
- * This file defines data structures for red-black trees.
+ * This file defines data structures for different types of trees:
+ * splay trees and red-black trees.
+ *
+ * A splay tree is a self-organizing data structure.  Every operation
+ * on the tree causes a splay to happen.  The splay moves the requested
+ * node to the root of the tree and partly rebalances it.
+ *
+ * This has the benefit that request locality causes faster lookups as
+ * the requested nodes move to the top of the tree.  On the other hand,
+ * every lookup causes memory writes.
+ *
+ * The Balance Theorem bounds the total access time for m operations
+ * and n inserts on an initially empty tree as O((m + n)lg n).  The
+ * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
+ *
  * A red-black tree is a binary search tree with the node color as an
  * extra attribute.  It fulfills a set of conditions:
  *  - every search path from the root to a leaf consists of the
@@ -47,6 +61,239 @@
  * The maximum height of a red-black tree is 2lg (n+1).
  */
 
+#define SPLAY_HEAD(name, type)                                                \
+struct name {                                                                 \
+  struct type *sph_root; /* root of the tree */                               \
+}
+
+#define SPLAY_INITIALIZER(root)                                               \
+  { NULL }
+
+#define SPLAY_INIT(root) do {                                                 \
+  (root)->sph_root = NULL;                                                    \
+} while (/*CONSTCOND*/ 0)
+
+#define SPLAY_ENTRY(type)                                                     \
+struct {                                                                      \
+  struct type *spe_left;          /* left element */                          \
+  struct type *spe_right;         /* right element */                         \
+}
+
+#define SPLAY_LEFT(elm, field)    (elm)->field.spe_left
+#define SPLAY_RIGHT(elm, field)   (elm)->field.spe_right
+#define SPLAY_ROOT(head)          (head)->sph_root
+#define SPLAY_EMPTY(head)         (SPLAY_ROOT(head) == NULL)
+
+/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
+#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {                             \
+  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);              \
+  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
+  (head)->sph_root = tmp;                                                     \
+} while (/*CONSTCOND*/ 0)
+
+#define SPLAY_ROTATE_LEFT(head, tmp, field) do {                              \
+  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);              \
+  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
+  (head)->sph_root = tmp;                                                     \
+} while (/*CONSTCOND*/ 0)
+
+#define SPLAY_LINKLEFT(head, tmp, field) do {                                 \
+  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \
+  tmp = (head)->sph_root;                                                     \
+  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                     \
+} while (/*CONSTCOND*/ 0)
+
+#define SPLAY_LINKRIGHT(head, tmp, field) do {                                \
+  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \
+  tmp = (head)->sph_root;                                                     \
+  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                    \
+} while (/*CONSTCOND*/ 0)
+
+#define SPLAY_ASSEMBLE(head, node, left, right, field) do {                   \
+  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);             \
+  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);            \
+  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);             \
+  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);             \
+} while (/*CONSTCOND*/ 0)
+
+/* Generates prototypes and inline functions */
+
+#define SPLAY_PROTOTYPE(name, type, field, cmp)                               \
+void name##_SPLAY(struct name *, struct type *);                              \
+void name##_SPLAY_MINMAX(struct name *, int);                                 \
+struct type *name##_SPLAY_INSERT(struct name *, struct type *);               \
+struct type *name##_SPLAY_REMOVE(struct name *, struct type *);               \
+                                                                              \
+/* Finds the node with the same key as elm */                                 \
+static __inline struct type *                                                 \
+name##_SPLAY_FIND(struct name *head, struct type *elm)                        \
+{                                                                             \
+  if (SPLAY_EMPTY(head))                                                      \
+    return(NULL);                                                             \
+  name##_SPLAY(head, elm);                                                    \
+  if ((cmp)(elm, (head)->sph_root) == 0)                                      \
+    return (head->sph_root);                                                  \
+  return (NULL);                                                              \
+}                                                                             \
+                                                                              \
+static __inline struct type *                                                 \
+name##_SPLAY_NEXT(struct name *head, struct type *elm)                        \
+{                                                                             \
+  name##_SPLAY(head, elm);                                                    \
+  if (SPLAY_RIGHT(elm, field) != NULL) {                                      \
+    elm = SPLAY_RIGHT(elm, field);                                            \
+    while (SPLAY_LEFT(elm, field) != NULL) {                                  \
+      elm = SPLAY_LEFT(elm, field);                                           \
+    }                                                                         \
+  } else                                                                      \
+    elm = NULL;                                                               \
+  return (elm);                                                               \
+}                                                                             \
+                                                                              \
+static __inline struct type *                                                 \
+name##_SPLAY_MIN_MAX(struct name *head, int val)                              \
+{                                                                             \
+  name##_SPLAY_MINMAX(head, val);                                             \
+  return (SPLAY_ROOT(head));                                                  \
+}
+
+/* Main splay operation.
+ * Moves node close to the key of elm to top
+ */
+#define SPLAY_GENERATE(name, type, field, cmp)                                \
+struct type *                                                                 \
+name##_SPLAY_INSERT(struct name *head, struct type *elm)                      \
+{                                                                             \
+    if (SPLAY_EMPTY(head)) {                                                  \
+      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;                \
+    } else {                                                                  \
+      int __comp;                                                             \
+      name##_SPLAY(head, elm);                                                \
+      __comp = (cmp)(elm, (head)->sph_root);                                  \
+      if(__comp < 0) {                                                        \
+        SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);         \
+        SPLAY_RIGHT(elm, field) = (head)->sph_root;                           \
+        SPLAY_LEFT((head)->sph_root, field) = NULL;                           \
+      } else if (__comp > 0) {                                                \
+        SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);       \
+        SPLAY_LEFT(elm, field) = (head)->sph_root;                            \
+        SPLAY_RIGHT((head)->sph_root, field) = NULL;                          \
+      } else                                                                  \
+        return ((head)->sph_root);                                            \
+    }                                                                         \
+    (head)->sph_root = (elm);                                                 \
+    return (NULL);                                                            \
+}                                                                             \
+                                                                              \
+struct type *                                                                 \
+name##_SPLAY_REMOVE(struct name *head, struct type *elm)                      \
+{                                                                             \
+  struct type *__tmp;                                                         \
+  if (SPLAY_EMPTY(head))                                                      \
+    return (NULL);                                                            \
+  name##_SPLAY(head, elm);                                                    \
+  if ((cmp)(elm, (head)->sph_root) == 0) {                                    \
+    if (SPLAY_LEFT((head)->sph_root, field) == NULL) {                        \
+      (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                \
+    } else {                                                                  \
+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
+      (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                 \
+      name##_SPLAY(head, elm);                                                \
+      SPLAY_RIGHT((head)->sph_root, field) = __tmp;                           \
+    }                                                                         \
+    return (elm);                                                             \
+  }                                                                           \
+  return (NULL);                                                              \
+}                                                                             \
+                                                                              \
+void                                                                          \
+name##_SPLAY(struct name *head, struct type *elm)                             \
+{                                                                             \
+  struct type __node, *__left, *__right, *__tmp;                              \
+  int __comp;                                                                 \
+                                                                              \
+  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
+  __left = __right = &__node;                                                 \
+                                                                              \
+  while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {                      \
+    if (__comp < 0) {                                                         \
+      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
+      if (__tmp == NULL)                                                      \
+        break;                                                                \
+      if ((cmp)(elm, __tmp) < 0){                                             \
+        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
+        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
+          break;                                                              \
+      }                                                                       \
+      SPLAY_LINKLEFT(head, __right, field);                                   \
+    } else if (__comp > 0) {                                                  \
+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
+      if (__tmp == NULL)                                                      \
+        break;                                                                \
+      if ((cmp)(elm, __tmp) > 0){                                             \
+        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
+        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
+          break;                                                              \
+      }                                                                       \
+      SPLAY_LINKRIGHT(head, __left, field);                                   \
+    }                                                                         \
+  }                                                                           \
+  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
+}                                                                             \
+                                                                              \
+/* Splay with either the minimum or the maximum element                       \
+ * Used to find minimum or maximum element in tree.                           \
+ */                                                                           \
+void name##_SPLAY_MINMAX(struct name *head, int __comp)                       \
+{                                                                             \
+  struct type __node, *__left, *__right, *__tmp;                              \
+                                                                              \
+  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \
+  __left = __right = &__node;                                                 \
+                                                                              \
+  for (;;) {                                                                  \
+    if (__comp < 0) {                                                         \
+      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \
+      if (__tmp == NULL)                                                      \
+        break;                                                                \
+      if (__comp < 0){                                                        \
+        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \
+        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \
+          break;                                                              \
+      }                                                                       \
+      SPLAY_LINKLEFT(head, __right, field);                                   \
+    } else if (__comp > 0) {                                                  \
+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \
+      if (__tmp == NULL)                                                      \
+        break;                                                                \
+      if (__comp > 0) {                                                       \
+        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \
+        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \
+          break;                                                              \
+      }                                                                       \
+      SPLAY_LINKRIGHT(head, __left, field);                                   \
+    }                                                                         \
+  }                                                                           \
+  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \
+}
+
+#define SPLAY_NEGINF  -1
+#define SPLAY_INF     1
+
+#define SPLAY_INSERT(name, x, y)  name##_SPLAY_INSERT(x, y)
+#define SPLAY_REMOVE(name, x, y)  name##_SPLAY_REMOVE(x, y)
+#define SPLAY_FIND(name, x, y)    name##_SPLAY_FIND(x, y)
+#define SPLAY_NEXT(name, x, y)    name##_SPLAY_NEXT(x, y)
+#define SPLAY_MIN(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
+                                  : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
+#define SPLAY_MAX(name, x)        (SPLAY_EMPTY(x) ? NULL                      \
+                                  : name##_SPLAY_MIN_MAX(x, SPLAY_INF))
+
+#define SPLAY_FOREACH(x, name, head)                                          \
+  for ((x) = SPLAY_MIN(name, head);                                           \
+       (x) != NULL;                                                           \
+       (x) = SPLAY_NEXT(name, head, x))
+
 /* Macros that define a red-black tree */
 #define RB_HEAD(name, type)                                                   \
 struct name {                                                                 \
@@ -483,8 +730,8 @@ name##_RB_MINMAX(struct name *head, int val)                                  \
 #define RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)
 #define RB_FIND(name, x, y)     name##_RB_FIND(x, y)
 #define RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)
-#define RB_NEXT(name, x)        name##_RB_NEXT(x)
-#define RB_PREV(name, x)        name##_RB_PREV(x)
+#define RB_NEXT(name, x, y)     name##_RB_NEXT(y)
+#define RB_PREV(name, x, y)     name##_RB_PREV(y)
 #define RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)
 #define RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)
 
diff --git a/deps/uv/include/uv/version.h b/deps/uv/include/uv/version.h
index 77a8b254174..d6a61a10f7c 100644
--- a/deps/uv/include/uv/version.h
+++ b/deps/uv/include/uv/version.h
@@ -31,8 +31,8 @@
  */
 
 #define UV_VERSION_MAJOR 1
-#define UV_VERSION_MINOR 49
-#define UV_VERSION_PATCH 1
+#define UV_VERSION_MINOR 48
+#define UV_VERSION_PATCH 0
 #define UV_VERSION_IS_RELEASE 1
 #define UV_VERSION_SUFFIX ""
 
diff --git a/deps/uv/include/uv/win.h b/deps/uv/include/uv/win.h
index 12ac53b4f21..f4adaa216c6 100644
--- a/deps/uv/include/uv/win.h
+++ b/deps/uv/include/uv/win.h
@@ -290,8 +290,8 @@ typedef struct {
 #define UV_ONCE_INIT { 0, NULL }
 
 typedef struct uv_once_s {
-  unsigned char unused;
-  INIT_ONCE init_once;
+  unsigned char ran;
+  HANDLE event;
 } uv_once_t;
 
 /* Platform-specific definitions for uv_spawn support. */
diff --git a/deps/uv/src/random.c b/deps/uv/src/random.c
index 57fc0d911da..e75f77deb2b 100644
--- a/deps/uv/src/random.c
+++ b/deps/uv/src/random.c
@@ -82,7 +82,7 @@ static void uv__random_done(struct uv__work* w, int status) {
   uv_random_t* req;
 
   req = container_of(w, uv_random_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   if (status == 0)
     status = req->status;
diff --git a/deps/uv/src/threadpool.c b/deps/uv/src/threadpool.c
index 45af50dcd04..dbef67f2f10 100644
--- a/deps/uv/src/threadpool.c
+++ b/deps/uv/src/threadpool.c
@@ -356,7 +356,7 @@ static void uv__queue_done(struct uv__work* w, int err) {
   uv_work_t* req;
 
   req = container_of(w, uv_work_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   if (req->after_work_cb == NULL)
     return;
diff --git a/deps/uv/src/unix/async.c b/deps/uv/src/unix/async.c
index bc97ec54c4f..0ff2669e30a 100644
--- a/deps/uv/src/unix/async.c
+++ b/deps/uv/src/unix/async.c
@@ -38,34 +38,6 @@
 #include <sys/eventfd.h>
 #endif
 
-#if UV__KQUEUE_EVFILT_USER
-static uv_once_t kqueue_runtime_detection_guard = UV_ONCE_INIT;
-static int kqueue_evfilt_user_support = 1;
-
-
-static void uv__kqueue_runtime_detection(void) {
-  int kq;
-  struct kevent ev[2];
-  struct timespec timeout = {0, 0};
-
-  /* Perform the runtime detection to ensure that kqueue with
-   * EVFILT_USER actually works. */
-  kq = kqueue();
-  EV_SET(ev, UV__KQUEUE_EVFILT_USER_IDENT, EVFILT_USER,
-         EV_ADD | EV_CLEAR, 0, 0, 0);
-  EV_SET(ev + 1, UV__KQUEUE_EVFILT_USER_IDENT, EVFILT_USER,
-         0, NOTE_TRIGGER, 0, 0);
-  if (kevent(kq, ev, 2, ev, 1, &timeout) < 1 || 
-      ev[0].filter != EVFILT_USER ||
-      ev[0].ident != UV__KQUEUE_EVFILT_USER_IDENT ||
-      ev[0].flags & EV_ERROR)
-    /* If we wind up here, we can assume that EVFILT_USER is defined but
-     * broken on the current system. */
-    kqueue_evfilt_user_support = 0;
-  uv__close(kq);
-}
-#endif
-
 static void uv__async_send(uv_loop_t* loop);
 static int uv__async_start(uv_loop_t* loop);
 static void uv__cpu_relax(void);
@@ -158,10 +130,8 @@ void uv__async_close(uv_async_t* handle) {
 
 
 static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
-#ifndef __linux__
   char buf[1024];
   ssize_t r;
-#endif
   struct uv__queue queue;
   struct uv__queue* q;
   uv_async_t* h;
@@ -169,12 +139,7 @@ static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
 
   assert(w == &loop->async_io_watcher);
 
-#ifndef __linux__
-#if UV__KQUEUE_EVFILT_USER
-  for (;!kqueue_evfilt_user_support;) {
-#else
   for (;;) {
-#endif
     r = read(w->fd, buf, sizeof(buf));
 
     if (r == sizeof(buf))
@@ -191,7 +156,6 @@ static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
 
     abort();
   }
-#endif /* !__linux__ */
 
   uv__queue_move(&loop->async_handles, &queue);
   while (!uv__queue_empty(&queue)) {
@@ -215,58 +179,34 @@ static void uv__async_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
 
 
 static void uv__async_send(uv_loop_t* loop) {
+  const void* buf;
+  ssize_t len;
   int fd;
-  ssize_t r;
-#ifdef __linux__
-  uint64_t val;
-
-  fd = loop->async_io_watcher.fd;  /* eventfd */
-  for (val = 1; /* empty */; val = 1) {
-    r = write(fd, &val, sizeof(uint64_t));
-    if (r < 0) {
-      /* When EAGAIN occurs, the eventfd counter hits the maximum value of the unsigned 64-bit.
-       * We need to first drain the eventfd and then write again.
-       *
-       * Check out https://man7.org/linux/man-pages/man2/eventfd.2.html for details.
-       */
-      if (errno == EAGAIN) {
-        /* It's ready to retry. */
-        if (read(fd, &val, sizeof(uint64_t)) > 0 || errno == EAGAIN) {
-          continue;
-        }
-      }
-      /* Unknown error occurs. */
-      break;
-    }
-    return;
-  }
-#else
-#if UV__KQUEUE_EVFILT_USER
-  struct kevent ev;
-
-  if (kqueue_evfilt_user_support) {
-    fd = loop->async_io_watcher.fd; /* magic number for EVFILT_USER */
-    EV_SET(&ev, fd, EVFILT_USER, 0, NOTE_TRIGGER, 0, 0);
-    r = kevent(loop->backend_fd, &ev, 1, NULL, 0, NULL);
-    if (r == 0)
-      return;
-    else
-      abort();
+  int r;
+
+  buf = "";
+  len = 1;
+  fd = loop->async_wfd;
+
+#if defined(__linux__)
+  if (fd == -1) {
+    static const uint64_t val = 1;
+    buf = &val;
+    len = sizeof(val);
+    fd = loop->async_io_watcher.fd;  /* eventfd */
   }
 #endif
 
-  fd = loop->async_wfd; /* write end of the pipe */
   do
-    r = write(fd, "x", 1);
+    r = write(fd, buf, len);
   while (r == -1 && errno == EINTR);
 
-  if (r == 1)
+  if (r == len)
     return;
 
   if (r == -1)
     if (errno == EAGAIN || errno == EWOULDBLOCK)
       return;
-#endif
 
   abort();
 }
@@ -275,9 +215,6 @@ static void uv__async_send(uv_loop_t* loop) {
 static int uv__async_start(uv_loop_t* loop) {
   int pipefd[2];
   int err;
-#if UV__KQUEUE_EVFILT_USER
-  struct kevent ev;
-#endif
 
   if (loop->async_io_watcher.fd != -1)
     return 0;
@@ -289,36 +226,6 @@ static int uv__async_start(uv_loop_t* loop) {
 
   pipefd[0] = err;
   pipefd[1] = -1;
-#elif UV__KQUEUE_EVFILT_USER
-  uv_once(&kqueue_runtime_detection_guard, uv__kqueue_runtime_detection);
-  if (kqueue_evfilt_user_support) {
-    /* In order not to break the generic pattern of I/O polling, a valid
-     * file descriptor is required to take up a room in loop->watchers,
-     * thus we create one for that, but this fd will not be actually used,
-     * it's just a placeholder and magic number which is going to be closed
-     * during the cleanup, as other FDs. */
-    err = uv__open_cloexec("/dev/null", O_RDONLY);
-    if (err < 0)
-      return err;
-
-    pipefd[0] = err;
-    pipefd[1] = -1;
-
-    /* When using EVFILT_USER event to wake up the kqueue, this event must be
-     * registered beforehand. Otherwise, calling kevent() to issue an
-     * unregistered EVFILT_USER event will get an ENOENT.
-     * Since uv__async_send() may happen before uv__io_poll() with multi-threads,
-     * we can't defer this registration of EVFILT_USER event as we did for other
-     * events, but must perform it right away. */
-    EV_SET(&ev, err, EVFILT_USER, EV_ADD | EV_CLEAR, 0, 0, 0);
-    err = kevent(loop->backend_fd, &ev, 1, NULL, 0, NULL);
-    if (err < 0)
-      return UV__ERR(errno);
-  } else {
-    err = uv__make_pipe(pipefd, UV_NONBLOCK_PIPE);
-    if (err < 0)
-      return err;
-  }
 #else
   err = uv__make_pipe(pipefd, UV_NONBLOCK_PIPE);
   if (err < 0)
@@ -329,13 +236,6 @@ static int uv__async_start(uv_loop_t* loop) {
   uv__io_start(loop, &loop->async_io_watcher, POLLIN);
   loop->async_wfd = pipefd[1];
 
-#if UV__KQUEUE_EVFILT_USER
-  /* Prevent the EVFILT_USER event from being added to kqueue redundantly
-   * and mistakenly later in uv__io_poll(). */
-  if (kqueue_evfilt_user_support)
-    loop->async_io_watcher.events = loop->async_io_watcher.pevents; 
-#endif
-
   return 0;
 }
 
diff --git a/deps/uv/src/unix/core.c b/deps/uv/src/unix/core.c
index 0c52ccf2ad7..965e7f77525 100644
--- a/deps/uv/src/unix/core.c
+++ b/deps/uv/src/unix/core.c
@@ -53,8 +53,7 @@
 
 #if defined(__APPLE__)
 # include <sys/filio.h>
-# include <sys/sysctl.h>
-#endif /* defined(__APPLE__) */
+# endif /* defined(__APPLE__) */
 
 
 #if defined(__APPLE__) && !TARGET_OS_IPHONE
@@ -95,15 +94,6 @@ extern char** environ;
 # define uv__accept4 accept4
 #endif
 
-#if defined(__FreeBSD__)
-# include <sys/param.h>
-# include <sys/cpuset.h>
-#endif
-
-#if defined(__NetBSD__)
-# include <sched.h>
-#endif
-
 #if defined(__linux__) && defined(__SANITIZE_THREAD__) && defined(__clang__)
 # include <sanitizer/linux_syscall_hooks.h>
 #endif
@@ -166,7 +156,7 @@ void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {
     break;
 
   case UV_TTY:
-    uv__tty_close((uv_tty_t*)handle);
+    uv__stream_close((uv_stream_t*)handle);
     break;
 
   case UV_TCP:
@@ -1034,7 +1024,7 @@ int uv_getrusage(uv_rusage_t* rusage) {
 #if defined(__APPLE__)
   rusage->ru_maxrss /= 1024;                  /* macOS and iOS report bytes. */
 #elif defined(__sun)
-  rusage->ru_maxrss *= getpagesize() / 1024;  /* Solaris reports pages. */
+  rusage->ru_maxrss /= getpagesize() / 1024;  /* Solaris reports pages. */
 #endif
 
   return 0;
@@ -1626,7 +1616,6 @@ static int set_nice_for_calling_thread(int priority) {
  * If the function fails, the return value is non-zero.
 */
 int uv_thread_setpriority(uv_thread_t tid, int priority) {
-#if !defined(__GNU__)
   int r;
   int min;
   int max;
@@ -1688,14 +1677,10 @@ int uv_thread_setpriority(uv_thread_t tid, int priority) {
     param.sched_priority = prio;
     r = pthread_setschedparam(tid, policy, &param);
     if (r != 0)
-      return UV__ERR(errno);
+      return UV__ERR(errno);  
   }
 
   return 0;
-#else  /* !defined(__GNU__) */
-  /* Simulate success on systems where thread priority is not implemented. */
-  return 0;
-#endif  /* !defined(__GNU__) */
 }
 
 int uv_os_uname(uv_utsname_t* buffer) {
@@ -1879,31 +1864,11 @@ int uv__search_path(const char* prog, char* buf, size_t* buflen) {
   return UV_EINVAL;
 }
 
-#if defined(__linux__) || defined (__FreeBSD__)
-# define uv__cpu_count(cpuset) CPU_COUNT(cpuset)
-#elif defined(__NetBSD__)
-static int uv__cpu_count(cpuset_t* set) {
-  int rc;
-  cpuid_t i;
-
-  rc = 0;
-  for (i = 0;; i++) {
-    int r = cpuset_isset(i, set);
-    if (r < 0)
-      break;
-    if (r)
-      rc++;
-  }
-
-  return rc;
-}
-#endif /* __NetBSD__ */
 
 unsigned int uv_available_parallelism(void) {
-  long rc = -1;
-
 #ifdef __linux__
   cpu_set_t set;
+  long rc;
 
   memset(&set, 0, sizeof(set));
 
@@ -1912,127 +1877,29 @@ unsigned int uv_available_parallelism(void) {
    * before falling back to sysconf(_SC_NPROCESSORS_ONLN).
    */
   if (0 == sched_getaffinity(0, sizeof(set), &set))
-    rc = uv__cpu_count(&set);
-#elif defined(__MVS__)
-  rc = __get_num_online_cpus();
+    rc = CPU_COUNT(&set);
+  else
+    rc = sysconf(_SC_NPROCESSORS_ONLN);
+
   if (rc < 1)
     rc = 1;
 
   return (unsigned) rc;
-#elif defined(__FreeBSD__)
-  cpuset_t set;
-
-  memset(&set, 0, sizeof(set));
-
-  if (0 == cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(set), &set))
-    rc = uv__cpu_count(&set);
-#elif defined(__NetBSD__)
-  cpuset_t* set = cpuset_create();
-  if (set != NULL) {
-    if (0 == sched_getaffinity_np(getpid(), sizeof(set), &set))
-      rc = uv__cpu_count(&set);
-    cpuset_destroy(set);
-  }
-#elif defined(__APPLE__)
-  int nprocs;
-  size_t i;
-  size_t len = sizeof(nprocs);
-  static const char *mib[] = {
-    "hw.activecpu",
-    "hw.logicalcpu",
-    "hw.ncpu"
-  };
-
-  for (i = 0; i < ARRAY_SIZE(mib); i++) {
-    if (0 == sysctlbyname(mib[i], &nprocs, &len, NULL, 0) &&
-	      len == sizeof(nprocs) &&
-	      nprocs > 0) {
-      rc = nprocs;
-      break;
-    }
-  }
-#elif defined(__OpenBSD__)
-  int nprocs;
-  size_t i;
-  size_t len = sizeof(nprocs);
-  static int mib[][2] = {
-# ifdef HW_NCPUONLINE
-    { CTL_HW, HW_NCPUONLINE },
-# endif
-    { CTL_HW, HW_NCPU }
-  };
-
-  for (i = 0; i < ARRAY_SIZE(mib); i++) {
-    if (0 == sysctl(mib[i], ARRAY_SIZE(mib[i]), &nprocs, &len, NULL, 0) &&
-	len == sizeof(nprocs) &&
-        nprocs > 0) {
-      rc = nprocs;
-      break;
-    }
-  }
-#endif /* __linux__ */
-
-  if (rc < 0)
-    rc = sysconf(_SC_NPROCESSORS_ONLN);
-
-#ifdef __linux__
-  {
-    double rc_with_cgroup;
-    uv__cpu_constraint c = {0, 0, 0.0};
-
-    if (uv__get_constrained_cpu(&c) == 0 && c.period_length > 0) {
-      rc_with_cgroup = (double)c.quota_per_period / c.period_length * c.proportions;
-      if (rc_with_cgroup < rc)
-        rc = (long)rc_with_cgroup; /* Casting is safe since rc_with_cgroup < rc < LONG_MAX */
-    }
-  }
-#endif  /* __linux__ */
+#elif defined(__MVS__)
+  int rc;
 
+  rc = __get_num_online_cpus();
   if (rc < 1)
     rc = 1;
 
   return (unsigned) rc;
-}
+#else  /* __linux__ */
+  long rc;
 
-int uv__sock_reuseport(int fd) {
-  int on = 1;
-#if defined(__FreeBSD__) && __FreeBSD__ >= 12 && defined(SO_REUSEPORT_LB)
-  /* FreeBSD 12 introduced a new socket option named SO_REUSEPORT_LB
-   * with the capability of load balancing, it's the substitution of
-   * the SO_REUSEPORTs on Linux and DragonFlyBSD. */
-  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT_LB, &on, sizeof(on)))
-    return UV__ERR(errno);
-#elif (defined(__linux__) || \
-      defined(_AIX73) || \
-      (defined(__DragonFly__) && __DragonFly_version >= 300600) || \
-      (defined(UV__SOLARIS_11_4) && UV__SOLARIS_11_4)) && \
-      defined(SO_REUSEPORT)
-  /* On Linux 3.9+, the SO_REUSEPORT implementation distributes connections
-   * evenly across all of the threads (or processes) that are blocked in
-   * accept() on the same port. As with TCP, SO_REUSEPORT distributes datagrams
-   * evenly across all of the receiving threads (or process).
-   *
-   * DragonFlyBSD 3.6.0 extended SO_REUSEPORT to distribute workload to
-   * available sockets, which made it the equivalent of Linux's SO_REUSEPORT.
-   *
-   * AIX 7.2.5 added the feature that would add the capability to distribute
-   * incoming connections or datagrams across all listening ports for SO_REUSEPORT.
-   *
-   * Solaris 11 supported SO_REUSEPORT, but it's implemented only for
-   * binding to the same address and port, without load balancing.
-   * Solaris 11.4 extended SO_REUSEPORT with the capability of load balancing.
-   */
-  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on)))
-    return UV__ERR(errno);
-#else
-  (void) (fd);
-  (void) (on);
-  /* SO_REUSEPORTs do not have the capability of load balancing on platforms
-   * other than those mentioned above. The semantics are completely different,
-   * therefore we shouldn't enable it, but fail this operation to indicate that
-   * UV_[TCP/UDP]_REUSEPORT is not supported on these platforms. */
-  return UV_ENOTSUP;
-#endif
+  rc = sysconf(_SC_NPROCESSORS_ONLN);
+  if (rc < 1)
+    rc = 1;
 
-  return 0;
+  return (unsigned) rc;
+#endif  /* __linux__ */
 }
diff --git a/deps/uv/src/unix/cygwin.c b/deps/uv/src/unix/cygwin.c
index 4913108223f..4e5413963d6 100644
--- a/deps/uv/src/unix/cygwin.c
+++ b/deps/uv/src/unix/cygwin.c
@@ -36,45 +36,9 @@ int uv_uptime(double* uptime) {
 }
 
 int uv_resident_set_memory(size_t* rss) {
-  char buf[1024];
-  const char* s;
-  long val;
-  int rc;
-  int i;
-  struct sysinfo si;
-
-  /* rss: 24th element */
-  rc = uv__slurp("/proc/self/stat", buf, sizeof(buf));
-  if (rc < 0)
-    return rc;
-
-  /* find the last ')' */
-  s = strrchr(buf, ')');
-  if (s == NULL)
-    goto err;
-
-  for (i = 1; i <= 22; i++) {
-    s = strchr(s + 1, ' ');
-    if (s == NULL)
-      goto err;
-  }
-
-  errno = 0;
-  val = strtol(s, NULL, 10);
-  if (val < 0 || errno != 0)
-    goto err;
-
-  do
-    rc = sysinfo(&si);
-  while (rc == -1 && errno == EINTR);
-  if (rc == -1)
-    return UV__ERR(errno);
-
-  *rss = val * si.mem_unit;
+  /* FIXME: read /proc/meminfo? */
+  *rss = 0;
   return 0;
-
-err:
-  return UV_EINVAL;
 }
 
 int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
diff --git a/deps/uv/src/unix/darwin-syscalls.h b/deps/uv/src/unix/darwin-syscalls.h
deleted file mode 100644
index dc2d1bd234b..00000000000
--- a/deps/uv/src/unix/darwin-syscalls.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef UV_DARWIN_SYSCALLS_H_
-#define UV_DARWIN_SYSCALLS_H_
-
-#include <sys/types.h>
-#include <sys/socket.h>
-
-/* https://github.com/apple/darwin-xnu/blob/master/bsd/sys/socket.h */
-
-struct mmsghdr {
-    struct msghdr msg_hdr;
-    size_t msg_len;
-};
-
-ssize_t recvmsg_x(int s, const struct mmsghdr* msgp, u_int cnt, int flags);
-ssize_t sendmsg_x(int s, const struct mmsghdr* msgp, u_int cnt, int flags);
-
-#endif /* UV_DARWIN_SYSCALLS_H_ */
diff --git a/deps/uv/src/unix/darwin.c b/deps/uv/src/unix/darwin.c
index 009efbefaa7..5e764a65ee4 100644
--- a/deps/uv/src/unix/darwin.c
+++ b/deps/uv/src/unix/darwin.c
@@ -25,6 +25,7 @@
 #include <stdint.h>
 #include <errno.h>
 
+#include <dlfcn.h>
 #include <mach/mach.h>
 #include <mach/mach_time.h>
 #include <mach-o/dyld.h> /* _NSGetExecutablePath */
@@ -33,6 +34,7 @@
 #include <unistd.h>  /* sysconf */
 
 static uv_once_t once = UV_ONCE_INIT;
+static uint64_t (*time_func)(void);
 static mach_timebase_info_data_t timebase;
 
 
@@ -54,12 +56,16 @@ void uv__platform_loop_delete(uv_loop_t* loop) {
 static void uv__hrtime_init_once(void) {
   if (KERN_SUCCESS != mach_timebase_info(&timebase))
     abort();
+
+  time_func = (uint64_t (*)(void)) dlsym(RTLD_DEFAULT, "mach_continuous_time");
+  if (time_func == NULL)
+    time_func = mach_absolute_time;
 }
 
 
 uint64_t uv__hrtime(uv_clocktype_t type) {
   uv_once(&once, uv__hrtime_init_once);
-  return mach_continuous_time() * timebase.numer / timebase.denom;
+  return time_func() * timebase.numer / timebase.denom;
 }
 
 
diff --git a/deps/uv/src/unix/freebsd.c b/deps/uv/src/unix/freebsd.c
index a6de29c558c..191bc8bc213 100644
--- a/deps/uv/src/unix/freebsd.c
+++ b/deps/uv/src/unix/freebsd.c
@@ -26,12 +26,7 @@
 #include <errno.h>
 
 #include <paths.h>
-#if defined(__DragonFly__)
-# include <sys/event.h>
-# include <sys/kinfo.h>
-#else
-# include <sys/user.h>
-#endif
+#include <sys/user.h>
 #include <sys/types.h>
 #include <sys/resource.h>
 #include <sys/sysctl.h>
diff --git a/deps/uv/src/unix/fs.c b/deps/uv/src/unix/fs.c
index 239ecda16a7..3a74350f0e5 100644
--- a/deps/uv/src/unix/fs.c
+++ b/deps/uv/src/unix/fs.c
@@ -31,7 +31,6 @@
 
 #include <errno.h>
 #include <dlfcn.h>
-#include <stdatomic.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -83,6 +82,17 @@
 # include <sys/statfs.h>
 #endif
 
+#if defined(__CYGWIN__) ||                                                    \
+    (defined(__HAIKU__) && B_HAIKU_VERSION < B_HAIKU_VERSION_1_PRE_BETA_5) || \
+    (defined(__sun) && !defined(__illumos__)) ||                              \
+    (defined(__APPLE__) && !TARGET_OS_IPHONE &&                               \
+     MAC_OS_X_VERSION_MIN_REQUIRED < 110000)
+#define preadv(fd, bufs, nbufs, off)                                          \
+  pread(fd, (bufs)->iov_base, (bufs)->iov_len, off)
+#define pwritev(fd, bufs, nbufs, off)                                         \
+  pwrite(fd, (bufs)->iov_base, (bufs)->iov_len, off)
+#endif
+
 #if defined(_AIX) && _XOPEN_SOURCE <= 600
 extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
 #endif
@@ -139,7 +149,7 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
 #define POST                                                                  \
   do {                                                                        \
     if (cb != NULL) {                                                         \
-      uv__req_register(loop);                                                 \
+      uv__req_register(loop, req);                                            \
       uv__work_submit(loop,                                                   \
                       &req->work_req,                                         \
                       UV__WORK_FAST_IO,                                       \
@@ -396,123 +406,6 @@ static ssize_t uv__fs_open(uv_fs_t* req) {
 }
 
 
-static ssize_t uv__preadv_or_pwritev_emul(int fd,
-                                          const struct iovec* bufs,
-                                          size_t nbufs,
-                                          off_t off,
-                                          int is_pread) {
-  ssize_t total;
-  ssize_t r;
-  size_t i;
-  size_t n;
-  void* p;
-
-  total = 0;
-  for (i = 0; i < (size_t) nbufs; i++) {
-    p = bufs[i].iov_base;
-    n = bufs[i].iov_len;
-
-    do
-      if (is_pread)
-        r = pread(fd, p, n, off);
-      else
-        r = pwrite(fd, p, n, off);
-    while (r == -1 && errno == EINTR);
-
-    if (r == -1) {
-      if (total > 0)
-        return total;
-      return -1;
-    }
-
-    off += r;
-    total += r;
-
-    if ((size_t) r < n)
-      return total;
-  }
-
-  return total;
-}
-
-
-#ifdef __linux__
-typedef int uv__iovcnt;
-#else
-typedef size_t uv__iovcnt;
-#endif
-
-
-static ssize_t uv__preadv_emul(int fd,
-                               const struct iovec* bufs,
-                               uv__iovcnt nbufs,
-                               off_t off) {
-  return uv__preadv_or_pwritev_emul(fd, bufs, nbufs, off, /*is_pread*/1);
-}
-
-
-static ssize_t uv__pwritev_emul(int fd,
-                                const struct iovec* bufs,
-                                uv__iovcnt nbufs,
-                                off_t off) {
-  return uv__preadv_or_pwritev_emul(fd, bufs, nbufs, off, /*is_pread*/0);
-}
-
-
-/* The function pointer cache is an uintptr_t because _Atomic void*
- * doesn't work on macos/ios/etc...
- * Disable optimization on armv7 to work around the bug described in
- * https://github.com/libuv/libuv/issues/4532
- */
-#if defined(__arm__) && (__ARM_ARCH == 7)
-__attribute__((optimize("O0")))
-#endif
-static ssize_t uv__preadv_or_pwritev(int fd,
-                                     const struct iovec* bufs,
-                                     size_t nbufs,
-                                     off_t off,
-                                     _Atomic uintptr_t* cache,
-                                     int is_pread) {
-  ssize_t (*f)(int, const struct iovec*, uv__iovcnt, off_t);
-  void* p;
-
-  p = (void*) atomic_load_explicit(cache, memory_order_relaxed);
-  if (p == NULL) {
-#ifdef RTLD_DEFAULT
-    p = dlsym(RTLD_DEFAULT, is_pread ? "preadv" : "pwritev");
-    dlerror();  /* Clear errors. */
-#endif  /* RTLD_DEFAULT */
-    if (p == NULL)
-      p = is_pread ? uv__preadv_emul : uv__pwritev_emul;
-    atomic_store_explicit(cache, (uintptr_t) p, memory_order_relaxed);
-  }
-
-  /* Use memcpy instead of `f = p` to work around a compiler bug,
-   * see https://github.com/libuv/libuv/issues/4532
-   */
-  memcpy(&f, &p, sizeof(p));
-  return f(fd, bufs, nbufs, off);
-}
-
-
-static ssize_t uv__preadv(int fd,
-                          const struct iovec* bufs,
-                          size_t nbufs,
-                          off_t off) {
-  static _Atomic uintptr_t cache;
-  return uv__preadv_or_pwritev(fd, bufs, nbufs, off, &cache, /*is_pread*/1);
-}
-
-
-static ssize_t uv__pwritev(int fd,
-                           const struct iovec* bufs,
-                           size_t nbufs,
-                           off_t off) {
-  static _Atomic uintptr_t cache;
-  return uv__preadv_or_pwritev(fd, bufs, nbufs, off, &cache, /*is_pread*/0);
-}
-
-
 static ssize_t uv__fs_read(uv_fs_t* req) {
   const struct iovec* bufs;
   unsigned int iovmax;
@@ -540,7 +433,7 @@ static ssize_t uv__fs_read(uv_fs_t* req) {
     if (nbufs == 1)
       r = pread(fd, bufs->iov_base, bufs->iov_len, off);
     else if (nbufs > 1)
-      r = uv__preadv(fd, bufs, nbufs, off);
+      r = preadv(fd, bufs, nbufs, off);
   }
 
 #ifdef __PASE__
@@ -798,23 +691,14 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
 
 static ssize_t uv__fs_realpath(uv_fs_t* req) {
   char* buf;
-  char* tmp;
 
 #if defined(_POSIX_VERSION) && _POSIX_VERSION >= 200809L
-  tmp = realpath(req->path, NULL);
-  if (tmp == NULL)
-    return -1;
-  buf = uv__strdup(tmp);
-  free(tmp); /* _Not_ uv__free. */
-  if (buf == NULL) {
-    errno = ENOMEM;
+  buf = realpath(req->path, NULL);
+  if (buf == NULL)
     return -1;
-  }
 #else
   ssize_t len;
 
-  (void)tmp;
-
   len = uv__fs_pathmax_size(req->path);
   buf = uv__malloc(len + 1);
 
@@ -1078,10 +962,7 @@ static ssize_t uv__fs_sendfile(uv_fs_t* req) {
 
     return -1;
   }
-/* sendfile() on iOS(arm64) will throw SIGSYS signal cause crash. */
-#elif (defined(__APPLE__) && !TARGET_OS_IPHONE)                               \
-    || defined(__DragonFly__)                                                 \
-    || defined(__FreeBSD__)
+#elif defined(__APPLE__) || defined(__DragonFly__) || defined(__FreeBSD__)
   {
     off_t len;
     ssize_t r;
@@ -1231,7 +1112,7 @@ static ssize_t uv__fs_write(uv_fs_t* req) {
     if (nbufs == 1)
       r = pwrite(fd, bufs->iov_base, bufs->iov_len, off);
     else if (nbufs > 1)
-      r = uv__pwritev(fd, bufs, nbufs, off);
+      r = pwritev(fd, bufs, nbufs, off);
   }
 
   return r;
@@ -1244,7 +1125,6 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {
   uv_file dstfd;
   struct stat src_statsbuf;
   struct stat dst_statsbuf;
-  struct timespec times[2];
   int dst_flags;
   int result;
   int err;
@@ -1322,35 +1202,6 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {
     }
   }
 
-  /**
-   * Change the timestamps of the destination file to match the source file.
-   */
-#if defined(__APPLE__)
-  times[0] = src_statsbuf.st_atimespec;
-  times[1] = src_statsbuf.st_mtimespec;
-#elif defined(_AIX)
-  times[0].tv_sec = src_statsbuf.st_atime;
-  times[0].tv_nsec = src_statsbuf.st_atime_n;
-  times[1].tv_sec = src_statsbuf.st_mtime;
-  times[1].tv_nsec = src_statsbuf.st_mtime_n;
-#else
-  times[0] = src_statsbuf.st_atim;
-  times[1] = src_statsbuf.st_mtim;
-#endif
-
-  if (futimens(dstfd, times) == -1) {
-    err = UV__ERR(errno);
-    goto out;
-  }
-
-  /*
-   * Change the ownership and permissions of the destination file to match the
-   * source file.
-   * `cp -p` does not care about errors here, so we don't either. Reuse the
-   * `result` variable to silence a -Wunused-result warning.
-   */
-  result = fchown(dstfd, src_statsbuf.st_uid, src_statsbuf.st_gid);
-
   if (fchmod(dstfd, src_statsbuf.st_mode) == -1) {
     err = UV__ERR(errno);
 #ifdef __linux__
@@ -1768,7 +1619,7 @@ static void uv__fs_done(struct uv__work* w, int status) {
   uv_fs_t* req;
 
   req = container_of(w, uv_fs_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   if (status == UV_ECANCELED) {
     assert(req->result == 0);
@@ -1780,7 +1631,7 @@ static void uv__fs_done(struct uv__work* w, int status) {
 
 
 void uv__fs_post(uv_loop_t* loop, uv_fs_t* req) {
-  uv__req_register(loop);
+  uv__req_register(loop, req);
   uv__work_submit(loop,
                   &req->work_req,
                   UV__WORK_FAST_IO,
@@ -1915,9 +1766,6 @@ int uv_fs_ftruncate(uv_loop_t* loop,
   INIT(FTRUNCATE);
   req->file = file;
   req->off = off;
-  if (cb != NULL)
-    if (uv__iou_fs_ftruncate(loop, req))
-      return 0;
   POST;
 }
 
diff --git a/deps/uv/src/unix/fsevents.c b/deps/uv/src/unix/fsevents.c
index 7fb6bb2ec36..df703f3635f 100644
--- a/deps/uv/src/unix/fsevents.c
+++ b/deps/uv/src/unix/fsevents.c
@@ -276,6 +276,10 @@ static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
         path += handle->realpath_len;
         len -= handle->realpath_len;
 
+        /* Ignore events with path equal to directory itself */
+        if (len <= 1 && (flags & kFSEventStreamEventFlagItemIsDir))
+          continue;
+
         if (len == 0) {
           /* Since we're using fsevents to watch the file itself,
            * realpath == path, and we now need to get the basename of the file back
@@ -789,7 +793,6 @@ int uv__cf_loop_signal(uv_loop_t* loop,
 
 /* Runs in UV loop to initialize handle */
 int uv__fsevents_init(uv_fs_event_t* handle) {
-  char* buf;
   int err;
   uv__cf_loop_state_t* state;
 
@@ -798,13 +801,9 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
     return err;
 
   /* Get absolute path to file */
-  buf = realpath(handle->path, NULL);
-  if (buf == NULL)
-    return UV__ERR(errno);
-  handle->realpath = uv__strdup(buf);
-  free(buf); /* _Not_ uv__free. */
+  handle->realpath = realpath(handle->path, NULL);
   if (handle->realpath == NULL)
-    return UV_ENOMEM;
+    return UV__ERR(errno);
   handle->realpath_len = strlen(handle->realpath);
 
   /* Initialize event queue */
diff --git a/deps/uv/src/unix/getaddrinfo.c b/deps/uv/src/unix/getaddrinfo.c
index b7075343666..77337ace945 100644
--- a/deps/uv/src/unix/getaddrinfo.c
+++ b/deps/uv/src/unix/getaddrinfo.c
@@ -109,7 +109,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
   uv_getaddrinfo_t* req;
 
   req = container_of(w, uv_getaddrinfo_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   /* See initialization in uv_getaddrinfo(). */
   if (req->hints)
diff --git a/deps/uv/src/unix/getnameinfo.c b/deps/uv/src/unix/getnameinfo.c
index 959b4c6a821..991002a67d7 100644
--- a/deps/uv/src/unix/getnameinfo.c
+++ b/deps/uv/src/unix/getnameinfo.c
@@ -58,7 +58,7 @@ static void uv__getnameinfo_done(struct uv__work* w, int status) {
   char* service;
 
   req = container_of(w, uv_getnameinfo_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
   host = service = NULL;
 
   if (status == UV_ECANCELED) {
diff --git a/deps/uv/src/unix/internal.h b/deps/uv/src/unix/internal.h
index 568a55b55ac..bcb3be577e5 100644
--- a/deps/uv/src/unix/internal.h
+++ b/deps/uv/src/unix/internal.h
@@ -35,10 +35,6 @@
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#if defined(__APPLE__) || defined(__DragonFly__) || \
-    defined(__FreeBSD__) || defined(__NetBSD__)
-#include <sys/event.h>
-#endif
 
 #define uv__msan_unpoison(p, n)                                               \
   do {                                                                        \
@@ -75,11 +71,8 @@
 # include <poll.h>
 #endif /* _AIX */
 
-#if defined(__APPLE__)
-# include "darwin-syscalls.h"
-# if !TARGET_OS_IPHONE
-#  include <AvailabilityMacros.h>
-# endif
+#if defined(__APPLE__) && !TARGET_OS_IPHONE
+# include <AvailabilityMacros.h>
 #endif
 
 /*
@@ -164,8 +157,7 @@ typedef struct uv__stream_queued_fds_s uv__stream_queued_fds_t;
 /* loop flags */
 enum {
   UV_LOOP_BLOCK_SIGPROF = 0x1,
-  UV_LOOP_REAP_CHILDREN = 0x2,
-  UV_LOOP_ENABLE_IO_URING_SQPOLL = 0x4
+  UV_LOOP_REAP_CHILDREN = 0x2
 };
 
 /* flags of excluding ifaddr */
@@ -251,7 +243,6 @@ int uv__close(int fd); /* preserves errno */
 int uv__close_nocheckstdio(int fd);
 int uv__close_nocancel(int fd);
 int uv__socket(int domain, int type, int protocol);
-int uv__sock_reuseport(int fd);
 ssize_t uv__recvmsg(int fd, struct msghdr *msg, int flags);
 void uv__make_close_pending(uv_handle_t* handle);
 int uv__getiovmax(void);
@@ -296,9 +287,6 @@ int uv__tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb);
 int uv__tcp_nodelay(int fd, int on);
 int uv__tcp_keepalive(int fd, int on, unsigned int delay);
 
-/* tty */
-void uv__tty_close(uv_tty_t* handle);
-
 /* pipe */
 int uv__pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);
 
@@ -344,7 +332,6 @@ int uv__random_sysctl(void* buf, size_t buflen);
 /* io_uring */
 #ifdef __linux__
 int uv__iou_fs_close(uv_loop_t* loop, uv_fs_t* req);
-int uv__iou_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req);
 int uv__iou_fs_fsync_or_fdatasync(uv_loop_t* loop,
                                   uv_fs_t* req,
                                   uint32_t fsync_flags);
@@ -363,7 +350,6 @@ int uv__iou_fs_symlink(uv_loop_t* loop, uv_fs_t* req);
 int uv__iou_fs_unlink(uv_loop_t* loop, uv_fs_t* req);
 #else
 #define uv__iou_fs_close(loop, req) 0
-#define uv__iou_fs_ftruncate(loop, req) 0
 #define uv__iou_fs_fsync_or_fdatasync(loop, req, fsync_flags) 0
 #define uv__iou_fs_link(loop, req) 0
 #define uv__iou_fs_mkdir(loop, req) 0
@@ -486,44 +472,4 @@ uv__fs_copy_file_range(int fd_in,
 #define UV__CPU_AFFINITY_SUPPORTED 0
 #endif
 
-#ifdef __linux__
-typedef struct {
-  long long quota_per_period;
-  long long period_length;
-  double proportions;
-} uv__cpu_constraint;
-
-int uv__get_constrained_cpu(uv__cpu_constraint* constraint);
-#endif
-
-#if defined(__sun) && !defined(__illumos__)
-#ifdef SO_FLOW_NAME
-/* Since it's impossible to detect the Solaris 11.4 version via OS macros,
- * so we check the presence of the socket option SO_FLOW_NAME that was first
- * introduced to Solaris 11.4 and define a custom macro for determining 11.4.
- */
-#define UV__SOLARIS_11_4 (1)
-#else
-#define UV__SOLARIS_11_4 (0)
-#endif
-#endif
-
-#if defined(EVFILT_USER) && defined(NOTE_TRIGGER)
-/* EVFILT_USER is available since OS X 10.6, DragonFlyBSD 4.0,
- * FreeBSD 8.1, and NetBSD 10.0.
- * 
- * Note that even though EVFILT_USER is defined on the current system,
- * it may still fail to work at runtime somehow. In that case, we fall
- * back to pipe-based signaling.
- */
-#define UV__KQUEUE_EVFILT_USER 1
-/* Magic number of identifier used for EVFILT_USER during runtime detection.
- * There are no Google hits for this number when I create it. That way,
- * people will be directed here if this number gets printed due to some
- * kqueue error and they google for help. */
-#define UV__KQUEUE_EVFILT_USER_IDENT 0x1e7e7711
-#else
-#define UV__KQUEUE_EVFILT_USER 0
-#endif
-
 #endif /* UV_UNIX_INTERNAL_H_ */
diff --git a/deps/uv/src/unix/kqueue.c b/deps/uv/src/unix/kqueue.c
index 876b717086c..4d09edc06a0 100644
--- a/deps/uv/src/unix/kqueue.c
+++ b/deps/uv/src/unix/kqueue.c
@@ -99,39 +99,6 @@ int uv__io_fork(uv_loop_t* loop) {
 int uv__io_check_fd(uv_loop_t* loop, int fd) {
   struct kevent ev;
   int rc;
-  struct stat sb;
-#ifdef __APPLE__
-  char path[MAXPATHLEN];
-#endif
-
-  if (uv__fstat(fd, &sb))
-    return UV__ERR(errno);
-
-  /* On FreeBSD, kqueue only supports EVFILT_READ notification for regular files
-   * and always reports ready events for writing, resulting in busy-looping.
-   *
-   * On Darwin, DragonFlyBSD, NetBSD and OpenBSD, kqueue reports ready events for
-   * regular files as readable and writable only once, acting like an EV_ONESHOT.
-   * 
-   * Neither of the above cases should be added to the kqueue.
-   */
-  if (S_ISREG(sb.st_mode) || S_ISDIR(sb.st_mode))
-    return UV_EINVAL;
-
-#ifdef __APPLE__
-  /* On Darwin (both macOS and iOS), in addition to regular files, FIFOs also don't
-   * work properly with kqueue: the disconnection from the last writer won't trigger
-   * an event for kqueue in spite of what the man pages say. Thus, we also disallow
-   * the case of S_IFIFO. */ 
-  if (S_ISFIFO(sb.st_mode)) {
-    /* File descriptors of FIFO, pipe and kqueue share the same type of file, 
-     * therefore there is no way to tell them apart via stat.st_mode&S_IFMT.
-     * Fortunately, FIFO is the only one that has a persisted file on filesystem,
-     * from which we're able to make the distinction for it. */
-    if (!fcntl(fd, F_GETPATH, path))
-      return UV_EINVAL;
-  }
-#endif
 
   rc = 0;
   EV_SET(&ev, fd, EVFILT_READ, EV_ADD, 0, 0, 0);
@@ -367,17 +334,6 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
         continue;
       }
 
-#if UV__KQUEUE_EVFILT_USER
-      if (ev->filter == EVFILT_USER) {
-        w = &loop->async_io_watcher;
-        assert(fd == w->fd);
-        uv__metrics_update_idle_time(loop);
-        w->cb(loop, w, w->events);
-        nevents++;
-        continue;
-      }
-#endif
-
       if (ev->filter == EVFILT_VNODE) {
         assert(w->events == POLLIN);
         assert(w->pevents == POLLIN);
diff --git a/deps/uv/src/unix/linux.c b/deps/uv/src/unix/linux.c
index 803a9a9d3f0..5a0800e112e 100644
--- a/deps/uv/src/unix/linux.c
+++ b/deps/uv/src/unix/linux.c
@@ -126,7 +126,6 @@
 
 enum {
   UV__IORING_SETUP_SQPOLL = 2u,
-  UV__IORING_SETUP_NO_SQARRAY = 0x10000u,
 };
 
 enum {
@@ -148,7 +147,6 @@ enum {
   UV__IORING_OP_MKDIRAT = 37,
   UV__IORING_OP_SYMLINKAT = 38,
   UV__IORING_OP_LINKAT = 39,
-  UV__IORING_OP_FTRUNCATE = 55,
 };
 
 enum {
@@ -161,6 +159,10 @@ enum {
   UV__IORING_SQ_CQ_OVERFLOW = 2u,
 };
 
+enum {
+  UV__MKDIRAT_SYMLINKAT_LINKAT = 1u,
+};
+
 struct uv__io_cqring_offsets {
   uint32_t head;
   uint32_t tail;
@@ -473,16 +475,8 @@ static int uv__use_io_uring(void) {
   use = atomic_load_explicit(&use_io_uring, memory_order_relaxed);
 
   if (use == 0) {
-    use = uv__kernel_version() >=
-#if defined(__hppa__)
-    /* io_uring first supported on parisc in 6.1, functional in .51 */
-    /* https://lore.kernel.org/all/cb912694-b1fe-dbb0-4d8c-d608f3526905@gmx.de/ */
-    /* 6.1.51 */ 0x060133
-#else
-    /* Older kernels have a bug where the sqpoll thread uses 100% CPU. */
-    /* 5.10.186 */ 0x050ABA
-#endif
-    ? 1 : -1;
+    /* Disable io_uring by default due to CVE-2024-22017. */
+    use = -1;
 
     /* But users can still enable it if they so desire. */
     val = getenv("UV_USE_IO_URING");
@@ -497,6 +491,14 @@ static int uv__use_io_uring(void) {
 }
 
 
+UV_EXTERN int uv__node_patch_is_using_io_uring(void) {
+  // This function exists only in the modified copy of libuv in the Node.js
+  // repository. Node.js checks if this function exists and, if it does, uses it
+  // to determine whether libuv is using io_uring or not.
+  return uv__use_io_uring();
+}
+
+
 static void uv__iou_init(int epollfd,
                          struct uv__iou* iou,
                          uint32_t entries,
@@ -507,13 +509,10 @@ static void uv__iou_init(int epollfd,
   size_t sqlen;
   size_t maxlen;
   size_t sqelen;
-  unsigned kernel_version;
-  uint32_t* sqarray;
   uint32_t i;
   char* sq;
   char* sqe;
   int ringfd;
-  int no_sqarray;
 
   sq = MAP_FAILED;
   sqe = MAP_FAILED;
@@ -521,15 +520,11 @@ static void uv__iou_init(int epollfd,
   if (!uv__use_io_uring())
     return;
 
-  kernel_version = uv__kernel_version();
-  no_sqarray =
-      UV__IORING_SETUP_NO_SQARRAY * (kernel_version >= /* 6.6 */0x060600);
-
   /* SQPOLL required CAP_SYS_NICE until linux v5.12 relaxed that requirement.
    * Mostly academic because we check for a v5.13 kernel afterwards anyway.
    */
   memset(&params, 0, sizeof(params));
-  params.flags = flags | no_sqarray;
+  params.flags = flags;
 
   if (flags & UV__IORING_SETUP_SQPOLL)
     params.sq_thread_idle = 10;  /* milliseconds */
@@ -591,6 +586,7 @@ static void uv__iou_init(int epollfd,
   iou->sqhead = (uint32_t*) (sq + params.sq_off.head);
   iou->sqtail = (uint32_t*) (sq + params.sq_off.tail);
   iou->sqmask = *(uint32_t*) (sq + params.sq_off.ring_mask);
+  iou->sqarray = (uint32_t*) (sq + params.sq_off.array);
   iou->sqflags = (uint32_t*) (sq + params.sq_off.flags);
   iou->cqhead = (uint32_t*) (sq + params.cq_off.head);
   iou->cqtail = (uint32_t*) (sq + params.cq_off.tail);
@@ -604,13 +600,13 @@ static void uv__iou_init(int epollfd,
   iou->sqelen = sqelen;
   iou->ringfd = ringfd;
   iou->in_flight = 0;
+  iou->flags = 0;
 
-  if (no_sqarray)
-    return;
+  if (uv__kernel_version() >= /* 5.15.0 */ 0x050F00)
+    iou->flags |= UV__MKDIRAT_SYMLINKAT_LINKAT;
 
-  sqarray = (uint32_t*) (sq + params.sq_off.array);
   for (i = 0; i <= iou->sqmask; i++)
-    sqarray[i] = i;  /* Slot -> sqe identity mapping. */
+    iou->sqarray[i] = i;  /* Slot -> sqe identity mapping. */
 
   return;
 
@@ -626,7 +622,7 @@ fail:
 
 
 static void uv__iou_delete(struct uv__iou* iou) {
-  if (iou->ringfd > -1) {
+  if (iou->ringfd != -1) {
     munmap(iou->sq, iou->maxlen);
     munmap(iou->sqe, iou->sqelen);
     uv__close(iou->ringfd);
@@ -640,7 +636,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {
 
   lfields = uv__get_internal_fields(loop);
   lfields->ctl.ringfd = -1;
-  lfields->iou.ringfd = -2;  /* "uninitialized" */
+  lfields->iou.ringfd = -1;
 
   loop->inotify_watchers = NULL;
   loop->inotify_fd = -1;
@@ -649,6 +645,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {
   if (loop->backend_fd == -1)
     return UV__ERR(errno);
 
+  uv__iou_init(loop->backend_fd, &lfields->iou, 64, UV__IORING_SETUP_SQPOLL);
   uv__iou_init(loop->backend_fd, &lfields->ctl, 256, 0);
 
   return 0;
@@ -716,17 +713,23 @@ void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {
    * This avoids a problem where the same file description remains open
    * in another process, causing repeated junk epoll events.
    *
-   * Perform EPOLL_CTL_DEL immediately instead of going through
-   * io_uring's submit queue, otherwise the file descriptor may
-   * be closed by the time the kernel starts the operation.
-   *
    * We pass in a dummy epoll_event, to work around a bug in old kernels.
    *
    * Work around a bug in kernels 3.10 to 3.19 where passing a struct that
    * has the EPOLLWAKEUP flag set generates spurious audit syslog warnings.
    */
   memset(&dummy, 0, sizeof(dummy));
-  epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, &dummy);
+
+  if (inv == NULL) {
+    epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, &dummy);
+  } else {
+    uv__epoll_ctl_prep(loop->backend_fd,
+                       &lfields->ctl,
+                       inv->prep,
+                       EPOLL_CTL_DEL,
+                       fd,
+                       &dummy);
+  }
 }
 
 
@@ -761,23 +764,6 @@ static struct uv__io_uring_sqe* uv__iou_get_sqe(struct uv__iou* iou,
   uint32_t mask;
   uint32_t slot;
 
-  /* Lazily create the ring. State machine: -2 means uninitialized, -1 means
-   * initialization failed. Anything else is a valid ring file descriptor.
-   */
-  if (iou->ringfd == -2) {
-    /* By default, the SQPOLL is not created. Enable only if the loop is
-     * configured with UV_LOOP_USE_IO_URING_SQPOLL.
-     */
-    if ((loop->flags & UV_LOOP_ENABLE_IO_URING_SQPOLL) == 0) {
-      iou->ringfd = -1;
-      return NULL;
-    }
-
-    uv__iou_init(loop->backend_fd, iou, 64, UV__IORING_SETUP_SQPOLL);
-    if (iou->ringfd == -2)
-      iou->ringfd = -1;  /* "failed" */
-  }
-
   if (iou->ringfd == -1)
     return NULL;
 
@@ -801,7 +787,7 @@ static struct uv__io_uring_sqe* uv__iou_get_sqe(struct uv__iou* iou,
   req->work_req.done = NULL;
   uv__queue_init(&req->work_req.wq);
 
-  uv__req_register(loop);
+  uv__req_register(loop, req);
   iou->in_flight++;
 
   return sqe;
@@ -864,26 +850,6 @@ int uv__iou_fs_close(uv_loop_t* loop, uv_fs_t* req) {
 }
 
 
-int uv__iou_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req) {
-  struct uv__io_uring_sqe* sqe;
-  struct uv__iou* iou;
-
-  if (uv__kernel_version() < /* 6.9 */0x060900)
-    return 0;
-
-  iou = &uv__get_internal_fields(loop)->iou;
-  sqe = uv__iou_get_sqe(iou, loop, req);
-  if (sqe == NULL)
-    return 0;
-
-  sqe->fd = req->file;
-  sqe->len = req->off;
-  sqe->opcode = UV__IORING_OP_FTRUNCATE;
-  uv__iou_submit(iou);
-
-  return 1;
-}
-
 int uv__iou_fs_fsync_or_fdatasync(uv_loop_t* loop,
                                   uv_fs_t* req,
                                   uint32_t fsync_flags) {
@@ -913,10 +879,11 @@ int uv__iou_fs_link(uv_loop_t* loop, uv_fs_t* req) {
   struct uv__io_uring_sqe* sqe;
   struct uv__iou* iou;
 
-  if (uv__kernel_version() < /* 5.15.0 */0x050F00)
+  iou = &uv__get_internal_fields(loop)->iou;
+
+  if (!(iou->flags & UV__MKDIRAT_SYMLINKAT_LINKAT))
     return 0;
 
-  iou = &uv__get_internal_fields(loop)->iou;
   sqe = uv__iou_get_sqe(iou, loop, req);
   if (sqe == NULL)
     return 0;
@@ -937,10 +904,11 @@ int uv__iou_fs_mkdir(uv_loop_t* loop, uv_fs_t* req) {
   struct uv__io_uring_sqe* sqe;
   struct uv__iou* iou;
 
-  if (uv__kernel_version() < /* 5.15.0 */0x050F00)
+  iou = &uv__get_internal_fields(loop)->iou;
+
+  if (!(iou->flags & UV__MKDIRAT_SYMLINKAT_LINKAT))
     return 0;
 
-  iou = &uv__get_internal_fields(loop)->iou;
   sqe = uv__iou_get_sqe(iou, loop, req);
   if (sqe == NULL)
     return 0;
@@ -1004,10 +972,11 @@ int uv__iou_fs_symlink(uv_loop_t* loop, uv_fs_t* req) {
   struct uv__io_uring_sqe* sqe;
   struct uv__iou* iou;
 
-  if (uv__kernel_version() < /* 5.15.0 */0x050F00)
+  iou = &uv__get_internal_fields(loop)->iou;
+
+  if (!(iou->flags & UV__MKDIRAT_SYMLINKAT_LINKAT))
     return 0;
 
-  iou = &uv__get_internal_fields(loop)->iou;
   sqe = uv__iou_get_sqe(iou, loop, req);
   if (sqe == NULL)
     return 0;
@@ -1186,7 +1155,7 @@ static void uv__poll_io_uring(uv_loop_t* loop, struct uv__iou* iou) {
     req = (uv_fs_t*) (uintptr_t) e->user_data;
     assert(req->type == UV_FS);
 
-    uv__req_unregister(loop);
+    uv__req_unregister(loop, req);
     iou->in_flight--;
 
     /* If the op is not supported by the kernel retry using the thread pool */
@@ -1238,10 +1207,6 @@ static void uv__poll_io_uring(uv_loop_t* loop, struct uv__iou* iou) {
 }
 
 
-/* Only for EPOLL_CTL_ADD and EPOLL_CTL_MOD. EPOLL_CTL_DEL should always be
- * executed immediately, otherwise the file descriptor may have been closed
- * by the time the kernel starts the operation.
- */
 static void uv__epoll_ctl_prep(int epollfd,
                                struct uv__iou* ctl,
                                struct epoll_event (*events)[256],
@@ -1253,28 +1218,45 @@ static void uv__epoll_ctl_prep(int epollfd,
   uint32_t mask;
   uint32_t slot;
 
-  assert(op == EPOLL_CTL_ADD || op == EPOLL_CTL_MOD);
-  assert(ctl->ringfd != -1);
+  if (ctl->ringfd == -1) {
+    if (!epoll_ctl(epollfd, op, fd, e))
+      return;
 
-  mask = ctl->sqmask;
-  slot = (*ctl->sqtail)++ & mask;
+    if (op == EPOLL_CTL_DEL)
+      return;  /* Ignore errors, may be racing with another thread. */
 
-  pe = &(*events)[slot];
-  *pe = *e;
+    if (op != EPOLL_CTL_ADD)
+      abort();
 
-  sqe = ctl->sqe;
-  sqe = &sqe[slot];
+    if (errno != EEXIST)
+      abort();
 
-  memset(sqe, 0, sizeof(*sqe));
-  sqe->addr = (uintptr_t) pe;
-  sqe->fd = epollfd;
-  sqe->len = op;
-  sqe->off = fd;
-  sqe->opcode = UV__IORING_OP_EPOLL_CTL;
-  sqe->user_data = op | slot << 2 | (int64_t) fd << 32;
+    /* File descriptor that's been watched before, update event mask. */
+    if (!epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, e))
+      return;
+
+    abort();
+  } else {
+    mask = ctl->sqmask;
+    slot = (*ctl->sqtail)++ & mask;
+
+    pe = &(*events)[slot];
+    *pe = *e;
+
+    sqe = ctl->sqe;
+    sqe = &sqe[slot];
 
-  if ((*ctl->sqhead & mask) == (*ctl->sqtail & mask))
-    uv__epoll_ctl_flush(epollfd, ctl, events);
+    memset(sqe, 0, sizeof(*sqe));
+    sqe->addr = (uintptr_t) pe;
+    sqe->fd = epollfd;
+    sqe->len = op;
+    sqe->off = fd;
+    sqe->opcode = UV__IORING_OP_EPOLL_CTL;
+    sqe->user_data = op | slot << 2 | (int64_t) fd << 32;
+
+    if ((*ctl->sqhead & mask) == (*ctl->sqtail & mask))
+      uv__epoll_ctl_flush(epollfd, ctl, events);
+  }
 }
 
 
@@ -1414,29 +1396,9 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
 
     w->events = w->pevents;
     e.events = w->pevents;
-    if (w == &loop->async_io_watcher)
-      /* Enable edge-triggered mode on async_io_watcher(eventfd),
-       * so that we're able to eliminate the overhead of reading
-       * the eventfd via system call on each event loop wakeup.
-       */
-      e.events |= EPOLLET;
     e.data.fd = w->fd;
-    fd = w->fd;
-
-    if (ctl->ringfd != -1) {
-      uv__epoll_ctl_prep(epollfd, ctl, &prep, op, fd, &e);
-      continue;
-    }
-
-    if (!epoll_ctl(epollfd, op, fd, &e))
-      continue;
 
-    assert(op == EPOLL_CTL_ADD);
-    assert(errno == EEXIST);
-
-    /* File descriptor that's been watched before, update event mask. */
-    if (epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &e))
-      abort();
+    uv__epoll_ctl_prep(epollfd, ctl, &prep, op, w->fd, &e);
   }
 
   inv.events = events;
@@ -1524,12 +1486,8 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
          *
          * Ignore all errors because we may be racing with another thread
          * when the file descriptor is closed.
-         *
-         * Perform EPOLL_CTL_DEL immediately instead of going through
-         * io_uring's submit queue, otherwise the file descriptor may
-         * be closed by the time the kernel starts the operation.
          */
-        epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, pe);
+        uv__epoll_ctl_prep(epollfd, ctl, &prep, EPOLL_CTL_DEL, fd, pe);
         continue;
       }
 
@@ -1664,17 +1622,36 @@ done:
 int uv_resident_set_memory(size_t* rss) {
   char buf[1024];
   const char* s;
+  ssize_t n;
   long val;
-  int rc;
+  int fd;
   int i;
 
-  /* rss: 24th element */
-  rc = uv__slurp("/proc/self/stat", buf, sizeof(buf));
-  if (rc < 0)
-    return rc;
+  do
+    fd = open("/proc/self/stat", O_RDONLY);
+  while (fd == -1 && errno == EINTR);
 
-  /* find the last ')' */
-  s = strrchr(buf, ')');
+  if (fd == -1)
+    return UV__ERR(errno);
+
+  do
+    n = read(fd, buf, sizeof(buf) - 1);
+  while (n == -1 && errno == EINTR);
+
+  uv__close(fd);
+  if (n == -1)
+    return UV__ERR(errno);
+  buf[n] = '\0';
+
+  s = strchr(buf, ' ');
+  if (s == NULL)
+    goto err;
+
+  s += 1;
+  if (*s != '(')
+    goto err;
+
+  s = strchr(s, ')');
   if (s == NULL)
     goto err;
 
@@ -1686,7 +1663,9 @@ int uv_resident_set_memory(size_t* rss) {
 
   errno = 0;
   val = strtol(s, NULL, 10);
-  if (val < 0 || errno != 0)
+  if (errno != 0)
+    goto err;
+  if (val < 0)
     goto err;
 
   *rss = val * getpagesize();
@@ -2291,136 +2270,6 @@ uint64_t uv_get_available_memory(void) {
 }
 
 
-static int uv__get_cgroupv2_constrained_cpu(const char* cgroup,
-                                            uv__cpu_constraint* constraint) {
-  char path[256];
-  char buf[1024];
-  unsigned int weight;
-  int cgroup_size;
-  const char* cgroup_trimmed;
-  char quota_buf[16];
-
-  if (strncmp(cgroup, "0::/", 4) != 0)
-    return UV_EINVAL;
-
-  /* Trim ending \n by replacing it with a 0 */
-  cgroup_trimmed = cgroup + sizeof("0::/") - 1;      /* Skip the prefix "0::/" */
-  cgroup_size = (int)strcspn(cgroup_trimmed, "\n");  /* Find the first slash */
-
-  /* Construct the path to the cpu.max file */
-  snprintf(path, sizeof(path), "/sys/fs/cgroup/%.*s/cpu.max", cgroup_size,
-           cgroup_trimmed);
-
-  /* Read cpu.max */
-  if (uv__slurp(path, buf, sizeof(buf)) < 0)
-    return UV_EIO;
-
-  if (sscanf(buf, "%15s %llu", quota_buf, &constraint->period_length) != 2)
-    return UV_EINVAL;
-
-  if (strncmp(quota_buf, "max", 3) == 0)
-    constraint->quota_per_period = LLONG_MAX;
-  else if (sscanf(quota_buf, "%lld", &constraint->quota_per_period) != 1)
-    return UV_EINVAL; // conversion failed
-
-  /* Construct the path to the cpu.weight file */
-  snprintf(path, sizeof(path), "/sys/fs/cgroup/%.*s/cpu.weight", cgroup_size,
-           cgroup_trimmed);
-
-  /* Read cpu.weight */
-  if (uv__slurp(path, buf, sizeof(buf)) < 0)
-    return UV_EIO;
-
-  if (sscanf(buf, "%u", &weight) != 1)
-    return UV_EINVAL;
-
-  constraint->proportions = (double)weight / 100.0;
-
-  return 0;
-}
-
-static char* uv__cgroup1_find_cpu_controller(const char* cgroup,
-                                             int* cgroup_size) {
-  /* Seek to the cpu controller line. */
-  char* cgroup_cpu = strstr(cgroup, ":cpu,");
-
-  if (cgroup_cpu != NULL) {
-    /* Skip the controller prefix to the start of the cgroup path. */
-    cgroup_cpu += sizeof(":cpu,") - 1;
-    /* Determine the length of the cgroup path, excluding the newline. */
-    *cgroup_size = (int)strcspn(cgroup_cpu, "\n");
-  }
-
-  return cgroup_cpu;
-}
-
-static int uv__get_cgroupv1_constrained_cpu(const char* cgroup,
-                                            uv__cpu_constraint* constraint) {
-  char path[256];
-  char buf[1024];
-  unsigned int shares;
-  int cgroup_size;
-  char* cgroup_cpu;
-
-  cgroup_cpu = uv__cgroup1_find_cpu_controller(cgroup, &cgroup_size);
-
-  if (cgroup_cpu == NULL)
-    return UV_EIO;
-
-  /* Construct the path to the cpu.cfs_quota_us file */
-  snprintf(path, sizeof(path), "/sys/fs/cgroup/%.*s/cpu.cfs_quota_us",
-           cgroup_size, cgroup_cpu);
-
-  if (uv__slurp(path, buf, sizeof(buf)) < 0)
-    return UV_EIO;
-
-  if (sscanf(buf, "%lld", &constraint->quota_per_period) != 1)
-    return UV_EINVAL;
-
-  /* Construct the path to the cpu.cfs_period_us file */
-  snprintf(path, sizeof(path), "/sys/fs/cgroup/%.*s/cpu.cfs_period_us",
-           cgroup_size, cgroup_cpu);
-
-  /* Read cpu.cfs_period_us */
-  if (uv__slurp(path, buf, sizeof(buf)) < 0)
-    return UV_EIO;
-
-  if (sscanf(buf, "%lld", &constraint->period_length) != 1)
-    return UV_EINVAL;
-
-  /* Construct the path to the cpu.shares file */
-  snprintf(path, sizeof(path), "/sys/fs/cgroup/%.*s/cpu.shares", cgroup_size,
-           cgroup_cpu);
-
-  /* Read cpu.shares */
-  if (uv__slurp(path, buf, sizeof(buf)) < 0)
-    return UV_EIO;
-
-  if (sscanf(buf, "%u", &shares) != 1)
-    return UV_EINVAL;
-
-  constraint->proportions = (double)shares / 1024.0;
-
-  return 0;
-}
-
-int uv__get_constrained_cpu(uv__cpu_constraint* constraint) {
-  char cgroup[1024];
-
-  /* Read the cgroup from /proc/self/cgroup */
-  if (uv__slurp("/proc/self/cgroup", cgroup, sizeof(cgroup)) < 0)
-    return UV_EIO;
-
-  /* Check if the system is using cgroup v2 by examining /proc/self/cgroup
-   * The entry for cgroup v2 is always in the format "0::$PATH"
-   * see https://docs.kernel.org/admin-guide/cgroup-v2.html */
-  if (strncmp(cgroup, "0::/", 4) == 0)
-    return uv__get_cgroupv2_constrained_cpu(cgroup, constraint);
-  else
-    return uv__get_cgroupv1_constrained_cpu(cgroup, constraint);
-}
-
-
 void uv_loadavg(double avg[3]) {
   struct sysinfo info;
   char buf[128];  /* Large enough to hold all of /proc/loadavg. */
diff --git a/deps/uv/src/unix/loop.c b/deps/uv/src/unix/loop.c
index 179ee999d80..a9468e8e19c 100644
--- a/deps/uv/src/unix/loop.c
+++ b/deps/uv/src/unix/loop.c
@@ -217,14 +217,6 @@ int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap) {
     return 0;
   }
 
-#if defined(__linux__)
-  if (option == UV_LOOP_USE_IO_URING_SQPOLL) {
-    loop->flags |= UV_LOOP_ENABLE_IO_URING_SQPOLL;
-    return 0;
-  }
-#endif
-
-
   if (option != UV_LOOP_BLOCK_SIGNAL)
     return UV_ENOSYS;
 
diff --git a/deps/uv/src/unix/pipe.c b/deps/uv/src/unix/pipe.c
index 1f9acfac41e..fca364426f8 100644
--- a/deps/uv/src/unix/pipe.c
+++ b/deps/uv/src/unix/pipe.c
@@ -76,13 +76,8 @@ int uv_pipe_bind2(uv_pipe_t* handle,
   if (name == NULL)
     return UV_EINVAL;
 
-  /* namelen==0 on Linux means autobind the listen socket in the abstract
-   * socket namespace, see `man 7 unix` for details.
-   */
-#if !defined(__linux__)
   if (namelen == 0)
     return UV_EINVAL;
-#endif
 
   if (includes_nul(name, namelen))
     return UV_EINVAL;
@@ -349,15 +344,8 @@ static int uv__pipe_getsockpeername(const uv_pipe_t* handle,
                                     uv__peersockfunc func,
                                     char* buffer,
                                     size_t* size) {
-#if defined(__linux__)
-  static const int is_linux = 1;
-#else
-  static const int is_linux = 0;
-#endif
   struct sockaddr_un sa;
   socklen_t addrlen;
-  size_t slop;
-  char* p;
   int err;
 
   addrlen = sizeof(sa);
@@ -371,20 +359,17 @@ static int uv__pipe_getsockpeername(const uv_pipe_t* handle,
     return err;
   }
 
-  slop = 1;
-  if (is_linux && sa.sun_path[0] == '\0') {
-    /* Linux abstract namespace. Not zero-terminated. */
-    slop = 0;
+#if defined(__linux__)
+  if (sa.sun_path[0] == 0)
+    /* Linux abstract namespace */
     addrlen -= offsetof(struct sockaddr_un, sun_path);
-  } else {
-    p = memchr(sa.sun_path, '\0', sizeof(sa.sun_path));
-    if (p == NULL)
-      p = ARRAY_END(sa.sun_path);
-    addrlen = p - sa.sun_path;
-  }
+  else
+#endif
+    addrlen = strlen(sa.sun_path);
+
 
-  if ((size_t)addrlen + slop > *size) {
-    *size = addrlen + slop;
+  if ((size_t)addrlen >= *size) {
+    *size = addrlen + 1;
     return UV_ENOBUFS;
   }
 
@@ -502,11 +487,7 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {
 int uv_pipe(uv_os_fd_t fds[2], int read_flags, int write_flags) {
   uv_os_fd_t temp[2];
   int err;
-#if defined(__linux__) || \
-    defined(__FreeBSD__) || \
-    defined(__OpenBSD__) || \
-    defined(__DragonFly__) || \
-    defined(__NetBSD__)
+#if defined(__FreeBSD__) || defined(__linux__)
   int flags = O_CLOEXEC;
 
   if ((read_flags & UV_NONBLOCK_PIPE) && (write_flags & UV_NONBLOCK_PIPE))
diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index f2038f2c0e8..4812a90f2f5 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -55,8 +55,7 @@
 extern char **environ;
 #endif
 
-#if defined(__linux__) || \
-    defined(__GNU__)
+#if defined(__linux__)
 # include <grp.h>
 #endif
 
@@ -64,7 +63,11 @@ extern char **environ;
 # include "zos-base.h"
 #endif
 
-#ifdef UV_HAVE_KQUEUE
+#if defined(__APPLE__) || \
+    defined(__DragonFly__) || \
+    defined(__FreeBSD__) || \
+    defined(__NetBSD__) || \
+    defined(__OpenBSD__)
 #include <sys/event.h>
 #else
 #define UV_USE_SIGCHLD
diff --git a/deps/uv/src/unix/signal.c b/deps/uv/src/unix/signal.c
index f23c887d0d6..bc4206e6d86 100644
--- a/deps/uv/src/unix/signal.c
+++ b/deps/uv/src/unix/signal.c
@@ -195,7 +195,7 @@ static void uv__signal_handler(int signum) {
 
   for (handle = uv__signal_first_handle(signum);
        handle != NULL && handle->signum == signum;
-       handle = RB_NEXT(uv__signal_tree_s, handle)) {
+       handle = RB_NEXT(uv__signal_tree_s, &uv__signal_tree, handle)) {
     int r;
 
     msg.signum = signum;
diff --git a/deps/uv/src/unix/stream.c b/deps/uv/src/unix/stream.c
index 18763b4744c..28c4d5463c4 100644
--- a/deps/uv/src/unix/stream.c
+++ b/deps/uv/src/unix/stream.c
@@ -457,7 +457,7 @@ void uv__stream_destroy(uv_stream_t* stream) {
   assert(stream->flags & UV_HANDLE_CLOSED);
 
   if (stream->connect_req) {
-    uv__req_unregister(stream->loop);
+    uv__req_unregister(stream->loop, stream->connect_req);
     stream->connect_req->cb(stream->connect_req, UV_ECANCELED);
     stream->connect_req = NULL;
   }
@@ -642,7 +642,7 @@ static void uv__drain(uv_stream_t* stream) {
   if ((stream->flags & UV_HANDLE_CLOSING) ||
       !(stream->flags & UV_HANDLE_SHUT)) {
     stream->shutdown_req = NULL;
-    uv__req_unregister(stream->loop);
+    uv__req_unregister(stream->loop, req);
 
     err = 0;
     if (stream->flags & UV_HANDLE_CLOSING)
@@ -698,8 +698,7 @@ static int uv__write_req_update(uv_stream_t* stream,
 
   do {
     len = n < buf->len ? n : buf->len;
-    if (buf->len != 0)
-      buf->base += len;
+    buf->base += len;
     buf->len -= len;
     buf += (buf->len == 0);  /* Advance to next buffer if this one is empty. */
     n -= len;
@@ -913,7 +912,7 @@ static void uv__write_callbacks(uv_stream_t* stream) {
     q = uv__queue_head(&pq);
     req = uv__queue_data(q, uv_write_t, queue);
     uv__queue_remove(q);
-    uv__req_unregister(stream->loop);
+    uv__req_unregister(stream->loop, req);
 
     if (req->bufs != NULL) {
       stream->write_queue_size -= uv__write_req_size(req);
@@ -980,13 +979,11 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
 
 static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
   struct cmsghdr* cmsg;
-  char* p;
-  char* pe;
   int fd;
   int err;
+  size_t i;
   size_t count;
 
-  err = 0;
   for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg)) {
     if (cmsg->cmsg_type != SCM_RIGHTS) {
       fprintf(stderr, "ignoring non-SCM_RIGHTS ancillary data: %d\n",
@@ -999,26 +996,24 @@ static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
     assert(count % sizeof(fd) == 0);
     count /= sizeof(fd);
 
-    p = (void*) CMSG_DATA(cmsg);
-    pe = p + count * sizeof(fd);
-
-    while (p < pe) {
-      memcpy(&fd, p, sizeof(fd));
-      p += sizeof(fd);
-
-      if (err == 0) {
-        if (stream->accepted_fd == -1)
-          stream->accepted_fd = fd;
-        else
-          err = uv__stream_queue_fd(stream, fd);
+    for (i = 0; i < count; i++) {
+      memcpy(&fd, (char*) CMSG_DATA(cmsg) + i * sizeof(fd), sizeof(fd));
+      /* Already has accepted fd, queue now */
+      if (stream->accepted_fd != -1) {
+        err = uv__stream_queue_fd(stream, fd);
+        if (err != 0) {
+          /* Close rest */
+          for (; i < count; i++)
+            uv__close(fd);
+          return err;
+        }
+      } else {
+        stream->accepted_fd = fd;
       }
-
-      if (err != 0)
-        uv__close(fd);
     }
   }
 
-  return err;
+  return 0;
 }
 
 
@@ -1273,7 +1268,7 @@ static void uv__stream_connect(uv_stream_t* stream) {
     return;
 
   stream->connect_req = NULL;
-  uv__req_unregister(stream->loop);
+  uv__req_unregister(stream->loop, req);
 
   if (error < 0 || uv__queue_empty(&stream->write_queue)) {
     uv__io_stop(stream->loop, &stream->io_watcher, POLLOUT);
diff --git a/deps/uv/src/unix/tcp.c b/deps/uv/src/unix/tcp.c
index 98970d75278..799fca77aa5 100644
--- a/deps/uv/src/unix/tcp.c
+++ b/deps/uv/src/unix/tcp.c
@@ -167,12 +167,6 @@ int uv__tcp_bind(uv_tcp_t* tcp,
   if (setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)))
     return UV__ERR(errno);
 
-  if (flags & UV_TCP_REUSEPORT) {
-    err = uv__sock_reuseport(tcp->io_watcher.fd);
-    if (err)
-      return err;
-  }
-
 #ifndef __OpenBSD__
 #ifdef IPV6_V6ONLY
   if (addr->sa_family == AF_INET6) {
@@ -458,14 +452,6 @@ int uv__tcp_nodelay(int fd, int on) {
 }
 
 
-#if (defined(UV__SOLARIS_11_4) && !UV__SOLARIS_11_4) || \
-    (defined(__DragonFly__) && __DragonFly_version < 500702)
-/* DragonFlyBSD <500702 and Solaris <11.4 require millisecond units
- * for TCP keepalive options. */
-#define UV_KEEPALIVE_FACTOR(x) (x *= 1000)
-#else
-#define UV_KEEPALIVE_FACTOR(x)
-#endif
 int uv__tcp_keepalive(int fd, int on, unsigned int delay) {
   int idle;
   int intvl;
@@ -481,8 +467,8 @@ int uv__tcp_keepalive(int fd, int on, unsigned int delay) {
   if (!on)
     return 0;
 
-  if (delay < 1)
-    return UV_EINVAL;
+  if (delay == 0)
+    return -1;
 
 #ifdef __sun
   /* The implementation of TCP keep-alive on Solaris/SmartOS is a bit unusual
@@ -515,53 +501,49 @@ int uv__tcp_keepalive(int fd, int on, unsigned int delay) {
   if (idle > 10*24*60*60)
     idle = 10*24*60*60;
 
-  UV_KEEPALIVE_FACTOR(idle);
-
   /* `TCP_KEEPIDLE`, `TCP_KEEPINTVL`, and `TCP_KEEPCNT` were not available on Solaris
    * until version 11.4, but let's take a chance here. */
 #if defined(TCP_KEEPIDLE) && defined(TCP_KEEPINTVL) && defined(TCP_KEEPCNT)
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle)))
     return UV__ERR(errno);
 
-  intvl = 10; /* required at least 10 seconds */
-  UV_KEEPALIVE_FACTOR(intvl);
+  intvl = idle/3;
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl)))
     return UV__ERR(errno);
 
-  cnt = 1; /* 1 retry, ensure (TCP_KEEPINTVL * TCP_KEEPCNT) is 10 seconds */
+  cnt = 3;
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt)))
     return UV__ERR(errno);
 #else
   /* Fall back to the first implementation of tcp-alive mechanism for older Solaris,
    * simulate the tcp-alive mechanism on other platforms via `TCP_KEEPALIVE_THRESHOLD` + `TCP_KEEPALIVE_ABORT_THRESHOLD`.
    */
+  idle *= 1000; /* kernel expects milliseconds */
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE_THRESHOLD, &idle, sizeof(idle)))
     return UV__ERR(errno);
 
   /* Note that the consequent probes will not be sent at equal intervals on Solaris,
    * but will be sent using the exponential backoff algorithm. */
-  int time_to_abort = 10; /* 10 seconds */
-  UV_KEEPALIVE_FACTOR(time_to_abort);
+  intvl = idle/3;
+  cnt = 3;
+  int time_to_abort = intvl * cnt;
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE_ABORT_THRESHOLD, &time_to_abort, sizeof(time_to_abort)))
     return UV__ERR(errno);
 #endif
 
 #else  /* !defined(__sun) */
 
-  idle = delay;
-  UV_KEEPALIVE_FACTOR(idle);
 #ifdef TCP_KEEPIDLE
-  if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle)))
+  if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay)))
     return UV__ERR(errno);
 #elif defined(TCP_KEEPALIVE)
   /* Darwin/macOS uses TCP_KEEPALIVE in place of TCP_KEEPIDLE. */
-  if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &idle, sizeof(idle)))
+  if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &delay, sizeof(delay)))
     return UV__ERR(errno);
 #endif
 
 #ifdef TCP_KEEPINTVL
-  intvl = 1;  /* 1 second; same as default on Win32 */
-  UV_KEEPALIVE_FACTOR(intvl);
+  intvl = 1;  /*  1 second; same as default on Win32 */
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intvl, sizeof(intvl)))
     return UV__ERR(errno);
 #endif
@@ -630,7 +612,7 @@ void uv__tcp_close(uv_tcp_t* handle) {
 int uv_socketpair(int type, int protocol, uv_os_sock_t fds[2], int flags0, int flags1) {
   uv_os_sock_t temp[2];
   int err;
-#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)
+#if defined(__FreeBSD__) || defined(__linux__)
   int flags;
 
   flags = type | SOCK_CLOEXEC;
diff --git a/deps/uv/src/unix/tty.c b/deps/uv/src/unix/tty.c
index 793054ba5a9..d099bdb3b67 100644
--- a/deps/uv/src/unix/tty.c
+++ b/deps/uv/src/unix/tty.c
@@ -335,37 +335,6 @@ int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {
 }
 
 
-void uv__tty_close(uv_tty_t* handle) {
-  int expected;
-  int fd;
-
-  fd = handle->io_watcher.fd;
-  if (fd == -1)
-    goto done;
-
-  /* This is used for uv_tty_reset_mode() */
-  do
-    expected = 0;
-  while (!atomic_compare_exchange_strong(&termios_spinlock, &expected, 1));
-
-  if (fd == orig_termios_fd) {
-    /* XXX(bnoordhuis) the tcsetattr is probably wrong when there are still
-     * other uv_tty_t handles active that refer to the same tty/pty but it's
-     * hard to recognize that particular situation without maintaining some
-     * kind of process-global data structure, and that still won't work in a
-     * multi-process setup.
-     */
-    uv__tcsetattr(fd, TCSANOW, &orig_termios);
-    orig_termios_fd = -1;
-  }
-
-  atomic_store(&termios_spinlock, 0);
-
-done:
-  uv__stream_close((uv_stream_t*) handle);
-}
-
-
 int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {
   struct winsize ws;
   int err;
@@ -483,7 +452,7 @@ int uv_tty_reset_mode(void) {
   saved_errno = errno;
 
   if (atomic_exchange(&termios_spinlock, 1))
-    return UV_EBUSY;  /* In uv_tty_set_mode() or uv__tty_close(). */
+    return UV_EBUSY;  /* In uv_tty_set_mode(). */
 
   err = 0;
   if (orig_termios_fd != -1)
diff --git a/deps/uv/src/unix/udp.c b/deps/uv/src/unix/udp.c
index f6640fc7231..c2814512a5f 100644
--- a/deps/uv/src/unix/udp.c
+++ b/deps/uv/src/unix/udp.c
@@ -100,7 +100,7 @@ static void uv__udp_run_completed(uv_udp_t* handle) {
     uv__queue_remove(q);
 
     req = uv__queue_data(q, uv_udp_send_t, queue);
-    uv__req_unregister(handle->loop);
+    uv__req_unregister(handle->loop, req);
 
     handle->send_queue_size -= uv__count_bufs(req->bufs, req->nbufs);
     handle->send_queue_count--;
@@ -141,14 +141,14 @@ static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) {
   if (revents & POLLIN)
     uv__udp_recvmsg(handle);
 
-  if (revents & POLLOUT && !uv__is_closing(handle)) {
+  if (revents & POLLOUT) {
     uv__udp_sendmsg(handle);
     uv__udp_run_completed(handle);
   }
 }
 
 static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__FreeBSD__)
   struct sockaddr_in6 peers[20];
   struct iovec iov[ARRAY_SIZE(peers)];
   struct mmsghdr msgs[ARRAY_SIZE(peers)];
@@ -173,18 +173,11 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
     msgs[k].msg_hdr.msg_control = NULL;
     msgs[k].msg_hdr.msg_controllen = 0;
     msgs[k].msg_hdr.msg_flags = 0;
-    msgs[k].msg_len = 0;
   }
 
-#if defined(__APPLE__)
-  do
-    nread = recvmsg_x(handle->io_watcher.fd, msgs, chunks, MSG_DONTWAIT);
-  while (nread == -1 && errno == EINTR);
-#else
   do
     nread = recvmmsg(handle->io_watcher.fd, msgs, chunks, 0, NULL);
   while (nread == -1 && errno == EINTR);
-#endif
 
   if (nread < 1) {
     if (nread == 0 || errno == EAGAIN || errno == EWOULDBLOCK)
@@ -211,9 +204,9 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
       handle->recv_cb(handle, 0, buf, NULL, UV_UDP_MMSG_FREE);
   }
   return nread;
-#else  /* __linux__ || ____FreeBSD__ || __APPLE__ */
+#else  /* __linux__ || ____FreeBSD__ */
   return UV_ENOSYS;
-#endif  /* __linux__ || ____FreeBSD__ || __APPLE__ */
+#endif  /* __linux__ || ____FreeBSD__ */
 }
 
 static void uv__udp_recvmsg(uv_udp_t* handle) {
@@ -282,61 +275,8 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
       && handle->recv_cb != NULL);
 }
 
-static void uv__udp_sendmsg_one(uv_udp_t* handle, uv_udp_send_t* req) {
-  struct uv__queue* q;
-  struct msghdr h;
-  ssize_t size;
-
-  for (;;) {
-    memset(&h, 0, sizeof h);
-    if (req->addr.ss_family == AF_UNSPEC) {
-      h.msg_name = NULL;
-      h.msg_namelen = 0;
-    } else {
-      h.msg_name = &req->addr;
-      if (req->addr.ss_family == AF_INET6)
-        h.msg_namelen = sizeof(struct sockaddr_in6);
-      else if (req->addr.ss_family == AF_INET)
-        h.msg_namelen = sizeof(struct sockaddr_in);
-      else if (req->addr.ss_family == AF_UNIX)
-        h.msg_namelen = sizeof(struct sockaddr_un);
-      else {
-        assert(0 && "unsupported address family");
-        abort();
-      }
-    }
-    h.msg_iov = (struct iovec*) req->bufs;
-    h.msg_iovlen = req->nbufs;
-
-    do
-      size = sendmsg(handle->io_watcher.fd, &h, 0);
-    while (size == -1 && errno == EINTR);
-
-    if (size == -1)
-      if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
-        return;
-
-    req->status = (size == -1 ? UV__ERR(errno) : size);
-
-    /* Sending a datagram is an atomic operation: either all data
-     * is written or nothing is (and EMSGSIZE is raised). That is
-     * why we don't handle partial writes. Just pop the request
-     * off the write queue and onto the completed queue, done.
-     */
-    uv__queue_remove(&req->queue);
-    uv__queue_insert_tail(&handle->write_completed_queue, &req->queue);
-    uv__io_feed(handle->loop, &handle->io_watcher);
-
-    if (uv__queue_empty(&handle->write_queue))
-      return;
-
-    q = uv__queue_head(&handle->write_queue);
-    req = uv__queue_data(q, uv_udp_send_t, queue);
-  }
-}
-
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
-static void uv__udp_sendmsg_many(uv_udp_t* handle) {
+static void uv__udp_sendmsg(uv_udp_t* handle) {
+#if defined(__linux__) || defined(__FreeBSD__)
   uv_udp_send_t* req;
   struct mmsghdr h[20];
   struct mmsghdr* p;
@@ -345,11 +285,16 @@ static void uv__udp_sendmsg_many(uv_udp_t* handle) {
   size_t pkts;
   size_t i;
 
+  if (uv__queue_empty(&handle->write_queue))
+    return;
+
 write_queue_drain:
   for (pkts = 0, q = uv__queue_head(&handle->write_queue);
        pkts < ARRAY_SIZE(h) && q != &handle->write_queue;
        ++pkts, q = uv__queue_head(q)) {
+    assert(q != NULL);
     req = uv__queue_data(q, uv_udp_send_t, queue);
+    assert(req != NULL);
 
     p = &h[pkts];
     memset(p, 0, sizeof(*p));
@@ -373,15 +318,9 @@ write_queue_drain:
     h[pkts].msg_hdr.msg_iovlen = req->nbufs;
   }
 
-#if defined(__APPLE__)
-  do
-    npkts = sendmsg_x(handle->io_watcher.fd, h, pkts, MSG_DONTWAIT);
-  while (npkts == -1 && errno == EINTR);
-#else
   do
     npkts = sendmmsg(handle->io_watcher.fd, h, pkts, 0);
   while (npkts == -1 && errno == EINTR);
-#endif
 
   if (npkts < 1) {
     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
@@ -389,7 +328,10 @@ write_queue_drain:
     for (i = 0, q = uv__queue_head(&handle->write_queue);
          i < pkts && q != &handle->write_queue;
          ++i, q = uv__queue_head(&handle->write_queue)) {
+      assert(q != NULL);
       req = uv__queue_data(q, uv_udp_send_t, queue);
+      assert(req != NULL);
+
       req->status = UV__ERR(errno);
       uv__queue_remove(&req->queue);
       uv__queue_insert_tail(&handle->write_completed_queue, &req->queue);
@@ -404,7 +346,10 @@ write_queue_drain:
   for (i = 0, q = uv__queue_head(&handle->write_queue);
        i < (size_t)npkts && q != &handle->write_queue;
        ++i, q = uv__queue_head(&handle->write_queue)) {
+    assert(q != NULL);
     req = uv__queue_data(q, uv_udp_send_t, queue);
+    assert(req != NULL);
+
     req->status = req->bufs[0].len;
 
     /* Sending a datagram is an atomic operation: either all data
@@ -419,48 +364,75 @@ write_queue_drain:
   /* couldn't batch everything, continue sending (jump to avoid stack growth) */
   if (!uv__queue_empty(&handle->write_queue))
     goto write_queue_drain;
-
   uv__io_feed(handle->loop, &handle->io_watcher);
-}
-#endif  /* __linux__ || ____FreeBSD__ || __APPLE__ */
-
-static void uv__udp_sendmsg(uv_udp_t* handle) {
-  struct uv__queue* q;
+#else  /* __linux__ || ____FreeBSD__ */
   uv_udp_send_t* req;
+  struct msghdr h;
+  struct uv__queue* q;
+  ssize_t size;
 
-  if (uv__queue_empty(&handle->write_queue))
-    return;
+  while (!uv__queue_empty(&handle->write_queue)) {
+    q = uv__queue_head(&handle->write_queue);
+    assert(q != NULL);
 
-  q = uv__queue_head(&handle->write_queue);
-  req = uv__queue_data(q, uv_udp_send_t, queue);
+    req = uv__queue_data(q, uv_udp_send_t, queue);
+    assert(req != NULL);
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
-  /* Use sendmmsg() if this send request contains more than one datagram OR
-   * there is more than one send request (because that automatically implies
-   * there is more than one datagram.)
-   */
-  if (req->nbufs != 1 || &handle->write_queue != uv__queue_next(&req->queue))
-    return uv__udp_sendmsg_many(handle);
-#endif
+    memset(&h, 0, sizeof h);
+    if (req->addr.ss_family == AF_UNSPEC) {
+      h.msg_name = NULL;
+      h.msg_namelen = 0;
+    } else {
+      h.msg_name = &req->addr;
+      if (req->addr.ss_family == AF_INET6)
+        h.msg_namelen = sizeof(struct sockaddr_in6);
+      else if (req->addr.ss_family == AF_INET)
+        h.msg_namelen = sizeof(struct sockaddr_in);
+      else if (req->addr.ss_family == AF_UNIX)
+        h.msg_namelen = sizeof(struct sockaddr_un);
+      else {
+        assert(0 && "unsupported address family");
+        abort();
+      }
+    }
+    h.msg_iov = (struct iovec*) req->bufs;
+    h.msg_iovlen = req->nbufs;
+
+    do {
+      size = sendmsg(handle->io_watcher.fd, &h, 0);
+    } while (size == -1 && errno == EINTR);
+
+    if (size == -1) {
+      if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)
+        break;
+    }
+
+    req->status = (size == -1 ? UV__ERR(errno) : size);
 
-  return uv__udp_sendmsg_one(handle, req);
+    /* Sending a datagram is an atomic operation: either all data
+     * is written or nothing is (and EMSGSIZE is raised). That is
+     * why we don't handle partial writes. Just pop the request
+     * off the write queue and onto the completed queue, done.
+     */
+    uv__queue_remove(&req->queue);
+    uv__queue_insert_tail(&handle->write_completed_queue, &req->queue);
+    uv__io_feed(handle->loop, &handle->io_watcher);
+  }
+#endif  /* __linux__ || ____FreeBSD__ */
 }
 
 /* On the BSDs, SO_REUSEPORT implies SO_REUSEADDR but with some additional
- * refinements for programs that use multicast. Therefore we preferentially
- * set SO_REUSEPORT over SO_REUSEADDR here, but we set SO_REUSEPORT only
- * when that socket option doesn't have the capability of load balancing.
- * Otherwise, we fall back to SO_REUSEADDR.
+ * refinements for programs that use multicast.
  *
- * Linux as of 3.9, DragonflyBSD 3.6, AIX 7.2.5 have the SO_REUSEPORT socket
- * option but with semantics that are different from the BSDs: it _shares_
- * the port rather than steals it from the current listener. While useful,
- * it's not something we can emulate on other platforms so we don't enable it.
+ * Linux as of 3.9 has a SO_REUSEPORT socket option but with semantics that
+ * are different from the BSDs: it _shares_ the port rather than steal it
+ * from the current listener.  While useful, it's not something we can emulate
+ * on other platforms so we don't enable it.
  *
  * zOS does not support getsockname with SO_REUSEPORT option when using
  * AF_UNIX.
  */
-static int uv__sock_reuseaddr(int fd) {
+static int uv__set_reuse(int fd) {
   int yes;
   yes = 1;
 
@@ -477,7 +449,7 @@ static int uv__sock_reuseaddr(int fd) {
        return UV__ERR(errno);
   }
 #elif defined(SO_REUSEPORT) && !defined(__linux__) && !defined(__GNU__) && \
-	!defined(__sun__) && !defined(__DragonFly__) && !defined(_AIX73)
+	!defined(__sun__)
   if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))
     return UV__ERR(errno);
 #else
@@ -520,8 +492,7 @@ int uv__udp_bind(uv_udp_t* handle,
   int fd;
 
   /* Check for bad flags. */
-  if (flags & ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR |
-                UV_UDP_REUSEPORT | UV_UDP_LINUX_RECVERR))
+  if (flags & ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR | UV_UDP_LINUX_RECVERR))
     return UV_EINVAL;
 
   /* Cannot set IPv6-only mode on non-IPv6 socket. */
@@ -544,13 +515,7 @@ int uv__udp_bind(uv_udp_t* handle,
   }
 
   if (flags & UV_UDP_REUSEADDR) {
-    err = uv__sock_reuseaddr(fd);
-    if (err)
-      return err;
-  }
-
-  if (flags & UV_UDP_REUSEPORT) {
-    err = uv__sock_reuseport(fd);
+    err = uv__set_reuse(fd);
     if (err)
       return err;
   }
@@ -757,7 +722,7 @@ int uv__udp_send(uv_udp_send_t* req,
     req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL) {
-    uv__req_unregister(handle->loop);
+    uv__req_unregister(handle->loop, req);
     return UV_ENOMEM;
   }
 
@@ -1050,7 +1015,7 @@ int uv__udp_init_ex(uv_loop_t* loop,
 
 
 int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__FreeBSD__)
   if (handle->flags & UV_HANDLE_UDP_RECVMMSG)
     return 1;
 #endif
@@ -1072,7 +1037,7 @@ int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
   if (err)
     return err;
 
-  err = uv__sock_reuseaddr(sock);
+  err = uv__set_reuse(sock);
   if (err)
     return err;
 
diff --git a/deps/uv/src/uv-common.h b/deps/uv/src/uv-common.h
index 4baede2e506..cd57e5a3515 100644
--- a/deps/uv/src/uv-common.h
+++ b/deps/uv/src/uv-common.h
@@ -233,13 +233,13 @@ void uv__threadpool_cleanup(void);
 #define uv__has_active_reqs(loop)                                             \
   ((loop)->active_reqs.count > 0)
 
-#define uv__req_register(loop)                                                \
+#define uv__req_register(loop, req)                                           \
   do {                                                                        \
     (loop)->active_reqs.count++;                                              \
   }                                                                           \
   while (0)
 
-#define uv__req_unregister(loop)                                              \
+#define uv__req_unregister(loop, req)                                         \
   do {                                                                        \
     assert(uv__has_active_reqs(loop));                                        \
     (loop)->active_reqs.count--;                                              \
@@ -349,7 +349,7 @@ void uv__threadpool_cleanup(void);
 #define uv__req_init(loop, req, typ)                                          \
   do {                                                                        \
     UV_REQ_INIT(req, typ);                                                    \
-    uv__req_register(loop);                                                   \
+    uv__req_register(loop, req);                                              \
   }                                                                           \
   while (0)
 
@@ -400,6 +400,7 @@ void uv__metrics_set_provider_entry_time(uv_loop_t* loop);
 struct uv__iou {
   uint32_t* sqhead;
   uint32_t* sqtail;
+  uint32_t* sqarray;
   uint32_t sqmask;
   uint32_t* sqflags;
   uint32_t* cqhead;
@@ -414,6 +415,7 @@ struct uv__iou {
   size_t sqelen;
   int ringfd;
   uint32_t in_flight;
+  uint32_t flags;
 };
 #endif  /* __linux__ */
 
diff --git a/deps/uv/src/win/error.c b/deps/uv/src/win/error.c
index 58587c5fb78..3a269da87a9 100644
--- a/deps/uv/src/win/error.c
+++ b/deps/uv/src/win/error.c
@@ -78,7 +78,6 @@ int uv_translate_sys_error(int sys_errno) {
     case WSAEADDRNOTAVAIL:                  return UV_EADDRNOTAVAIL;
     case WSAEAFNOSUPPORT:                   return UV_EAFNOSUPPORT;
     case WSAEWOULDBLOCK:                    return UV_EAGAIN;
-    case ERROR_NO_DATA:                     return UV_EAGAIN;
     case WSAEALREADY:                       return UV_EALREADY;
     case ERROR_INVALID_FLAGS:               return UV_EBADF;
     case ERROR_INVALID_HANDLE:              return UV_EBADF;
@@ -158,6 +157,7 @@ int uv_translate_sys_error(int sys_errno) {
     case ERROR_ACCESS_DENIED:               return UV_EPERM;
     case ERROR_PRIVILEGE_NOT_HELD:          return UV_EPERM;
     case ERROR_BAD_PIPE:                    return UV_EPIPE;
+    case ERROR_NO_DATA:                     return UV_EPIPE;
     case ERROR_PIPE_NOT_CONNECTED:          return UV_EPIPE;
     case WSAESHUTDOWN:                      return UV_EPIPE;
     case WSAEPROTONOSUPPORT:                return UV_EPROTONOSUPPORT;
@@ -168,16 +168,6 @@ int uv_translate_sys_error(int sys_errno) {
     case ERROR_INVALID_FUNCTION:            return UV_EISDIR;
     case ERROR_META_EXPANSION_TOO_LONG:     return UV_E2BIG;
     case WSAESOCKTNOSUPPORT:                return UV_ESOCKTNOSUPPORT;
-    case ERROR_BAD_EXE_FORMAT:              return UV_EFTYPE;
     default:                                return UV_UNKNOWN;
   }
 }
-
-int uv_translate_write_sys_error(int sys_errno) {
-  switch (sys_errno) {
-    case ERROR_BROKEN_PIPE:                 return UV_EPIPE;
-    case ERROR_NO_DATA:                     return UV_EPIPE;
-    default:
-      return uv_translate_sys_error(sys_errno);
-  }
-}
diff --git a/deps/uv/src/win/fs-event.c b/deps/uv/src/win/fs-event.c
index 7ab407e0534..fce411813e9 100644
--- a/deps/uv/src/win/fs-event.c
+++ b/deps/uv/src/win/fs-event.c
@@ -561,25 +561,7 @@ void uv__process_fs_event_req(uv_loop_t* loop, uv_req_t* req,
     }
   } else {
     err = GET_REQ_ERROR(req);
-    /*
-     * Check whether the ERROR_ACCESS_DENIED is caused by the watched directory
-     * being actually deleted (not an actual error) or a legit error. Retrieve
-     * FileStandardInfo to check whether the directory is pending deletion.
-     */
-    FILE_STANDARD_INFO info;
-    if (err == ERROR_ACCESS_DENIED &&
-        handle->dirw != NULL &&
-        GetFileInformationByHandleEx(handle->dir_handle,
-                                     FileStandardInfo,
-                                     &info,
-                                     sizeof(info)) &&
-        info.Directory &&
-        info.DeletePending) {
-      uv__convert_utf16_to_utf8(handle->dirw, -1, &filename);
-      handle->cb(handle, filename, UV_RENAME, 0);
-    } else {
-      handle->cb(handle, NULL, 0, uv_translate_sys_error(err));
-    }
+    handle->cb(handle, NULL, 0, uv_translate_sys_error(err));
   }
 
   if (handle->flags & UV_HANDLE_CLOSING) {
diff --git a/deps/uv/src/win/fs.c b/deps/uv/src/win/fs.c
index 08b42eb14c9..b73c17d8c1c 100644
--- a/deps/uv/src/win/fs.c
+++ b/deps/uv/src/win/fs.c
@@ -46,17 +46,6 @@
 #define UV_FS_FREE_PTR           0x0008
 #define UV_FS_CLEANEDUP          0x0010
 
-#ifndef FILE_DISPOSITION_DELETE
-#define FILE_DISPOSITION_DELETE                     0x0001
-#endif  /* FILE_DISPOSITION_DELETE */
-
-#ifndef FILE_DISPOSITION_POSIX_SEMANTICS
-#define FILE_DISPOSITION_POSIX_SEMANTICS            0x0002
-#endif  /* FILE_DISPOSITION_POSIX_SEMANTICS */
-
-#ifndef FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE
-#define FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE  0x0010
-#endif  /* FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE */
 
 #define INIT(subtype)                                                         \
   do {                                                                        \
@@ -69,7 +58,7 @@
 #define POST                                                                  \
   do {                                                                        \
     if (cb != NULL) {                                                         \
-      uv__req_register(loop);                                                 \
+      uv__req_register(loop, req);                                            \
       uv__work_submit(loop,                                                   \
                       &req->work_req,                                         \
                       UV__WORK_FAST_IO,                                       \
@@ -108,14 +97,13 @@
     return;                                                                 \
   }
 
-#define NSEC_PER_TICK 100
-#define TICKS_PER_SEC ((int64_t) 1e9 / NSEC_PER_TICK)
-static const int64_t WIN_TO_UNIX_TICK_OFFSET = 11644473600 * TICKS_PER_SEC;
+#define MILLION ((int64_t) 1000 * 1000)
+#define BILLION ((int64_t) 1000 * 1000 * 1000)
 
 static void uv__filetime_to_timespec(uv_timespec_t *ts, int64_t filetime) {
-  filetime -= WIN_TO_UNIX_TICK_OFFSET;
-  ts->tv_sec = filetime / TICKS_PER_SEC;
-  ts->tv_nsec = (filetime % TICKS_PER_SEC) * NSEC_PER_TICK;
+  filetime -= 116444736 * BILLION;
+  ts->tv_sec = (long) (filetime / (10 * MILLION));
+  ts->tv_nsec = (long) ((filetime - ts->tv_sec * 10 * MILLION) * 100U);
   if (ts->tv_nsec < 0) {
     ts->tv_sec -= 1;
     ts->tv_nsec += 1e9;
@@ -124,7 +112,7 @@ static void uv__filetime_to_timespec(uv_timespec_t *ts, int64_t filetime) {
 
 #define TIME_T_TO_FILETIME(time, filetime_ptr)                              \
   do {                                                                      \
-    int64_t bigtime = ((time) * TICKS_PER_SEC + WIN_TO_UNIX_TICK_OFFSET);   \
+    int64_t bigtime = ((time) * 10 * MILLION + 116444736 * BILLION);        \
     (filetime_ptr)->dwLowDateTime = (uint64_t) bigtime & 0xFFFFFFFF;        \
     (filetime_ptr)->dwHighDateTime = (uint64_t) bigtime >> 32;              \
   } while(0)
@@ -148,16 +136,6 @@ static int uv__file_symlink_usermode_flag = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGE
 
 static DWORD uv__allocation_granularity;
 
-typedef enum {
-  FS__STAT_PATH_SUCCESS,
-  FS__STAT_PATH_ERROR,
-  FS__STAT_PATH_TRY_SLOW
-} fs__stat_path_return_t;
-
-INLINE static void fs__stat_assign_statbuf_null(uv_stat_t* statbuf);
-INLINE static void fs__stat_assign_statbuf(uv_stat_t* statbuf,
-    FILE_STAT_BASIC_INFORMATION stat_info, int do_lstat);
-
 
 void uv__fs_init(void) {
   SYSTEM_INFO system_info;
@@ -1078,20 +1056,27 @@ void fs__write(uv_fs_t* req) {
       error = ERROR_INVALID_FLAGS;
     }
 
-    SET_REQ_UV_ERROR(req, uv_translate_write_sys_error(error), error);
+    SET_REQ_WIN32_ERROR(req, error);
   }
 }
 
 
-static void fs__unlink_rmdir(uv_fs_t* req, BOOL isrmdir) {
+void fs__rmdir(uv_fs_t* req) {
+  int result = _wrmdir(req->file.pathw);
+  if (result == -1)
+    SET_REQ_WIN32_ERROR(req, _doserrno);
+  else
+    SET_REQ_RESULT(req, 0);
+}
+
+
+void fs__unlink(uv_fs_t* req) {
   const WCHAR* pathw = req->file.pathw;
   HANDLE handle;
   BY_HANDLE_FILE_INFORMATION info;
   FILE_DISPOSITION_INFORMATION disposition;
-  FILE_DISPOSITION_INFORMATION_EX disposition_ex;
   IO_STATUS_BLOCK iosb;
   NTSTATUS status;
-  DWORD error;
 
   handle = CreateFileW(pathw,
                        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | DELETE,
@@ -1112,18 +1097,10 @@ static void fs__unlink_rmdir(uv_fs_t* req, BOOL isrmdir) {
     return;
   }
 
-  if (isrmdir && !(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
-    /* Error if we're in rmdir mode but it is not a dir.
-     * TODO: change it to UV_NOTDIR in v2. */
-    SET_REQ_UV_ERROR(req, UV_ENOENT, ERROR_DIRECTORY);
-    CloseHandle(handle);
-    return;
-  }
-
-  if (!isrmdir && (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
-    /* If not explicitly allowed, do not allow deletion of directories, unless
-     * it is a symlink. When the path refers to a non-symlink directory, report
-     * EPERM as mandated by POSIX.1. */
+  if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+    /* Do not allow deletion of directories, unless it is a symlink. When the
+     * path refers to a non-symlink directory, report EPERM as mandated by
+     * POSIX.1. */
 
     /* Check if it is a reparse point. If it's not, it's a normal directory. */
     if (!(info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
@@ -1135,7 +1112,7 @@ static void fs__unlink_rmdir(uv_fs_t* req, BOOL isrmdir) {
     /* Read the reparse point and check if it is a valid symlink. If not, don't
      * unlink. */
     if (fs__readlink_handle(handle, NULL, NULL) < 0) {
-      error = GetLastError();
+      DWORD error = GetLastError();
       if (error == ERROR_SYMLINK_NOT_SUPPORTED)
         error = ERROR_ACCESS_DENIED;
       SET_REQ_WIN32_ERROR(req, error);
@@ -1144,77 +1121,42 @@ static void fs__unlink_rmdir(uv_fs_t* req, BOOL isrmdir) {
     }
   }
 
-  /* Try posix delete first */
-  disposition_ex.Flags = FILE_DISPOSITION_DELETE | FILE_DISPOSITION_POSIX_SEMANTICS |
-                          FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE;
+  if (info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
+    /* Remove read-only attribute */
+    FILE_BASIC_INFORMATION basic = { 0 };
+
+    basic.FileAttributes = (info.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY) |
+                           FILE_ATTRIBUTE_ARCHIVE;
+
+    status = pNtSetInformationFile(handle,
+                                   &iosb,
+                                   &basic,
+                                   sizeof basic,
+                                   FileBasicInformation);
+    if (!NT_SUCCESS(status)) {
+      SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(status));
+      CloseHandle(handle);
+      return;
+    }
+  }
 
+  /* Try to set the delete flag. */
+  disposition.DeleteFile = TRUE;
   status = pNtSetInformationFile(handle,
                                  &iosb,
-                                 &disposition_ex,
-                                 sizeof disposition_ex,
-                                 FileDispositionInformationEx);
+                                 &disposition,
+                                 sizeof disposition,
+                                 FileDispositionInformation);
   if (NT_SUCCESS(status)) {
     SET_REQ_SUCCESS(req);
   } else {
-    /* If status == STATUS_CANNOT_DELETE here, given we set
-     * FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE, STATUS_CANNOT_DELETE can only mean
-     * that there is an existing mapped view to the file, preventing delete.
-     * STATUS_CANNOT_DELETE maps to UV_EACCES so it's not specifically worth handling  */
-    error = pRtlNtStatusToDosError(status);
-    if (error == ERROR_NOT_SUPPORTED /* filesystem does not support posix deletion */ ||
-        error == ERROR_INVALID_PARAMETER /* pre Windows 10 error */ ||
-        error == ERROR_INVALID_FUNCTION /* pre Windows 10 1607 error */) {
-      /* posix delete not supported so try fallback */
-      if (info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
-        /* Remove read-only attribute */
-        FILE_BASIC_INFORMATION basic = { 0 };
-
-        basic.FileAttributes = (info.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY) |
-                              FILE_ATTRIBUTE_ARCHIVE;
-
-        status = pNtSetInformationFile(handle,
-                                      &iosb,
-                                      &basic,
-                                      sizeof basic,
-                                      FileBasicInformation);
-        if (!NT_SUCCESS(status)) {
-          SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(status));
-          CloseHandle(handle);
-          return;
-        }
-      }
-
-      /* Try to set the delete flag. */
-      disposition.DeleteFile = TRUE;
-      status = pNtSetInformationFile(handle,
-                                    &iosb,
-                                    &disposition,
-                                    sizeof disposition,
-                                    FileDispositionInformation);
-      if (NT_SUCCESS(status)) {
-        SET_REQ_SUCCESS(req);
-      } else {
-        SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(status));
-      }
-    } else {
-      SET_REQ_WIN32_ERROR(req, error);
-    }
+    SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(status));
   }
 
   CloseHandle(handle);
 }
 
 
-static void fs__rmdir(uv_fs_t* req) {
-  fs__unlink_rmdir(req, /*isrmdir*/1);
-}
-
-
-static void fs__unlink(uv_fs_t* req) {
-  fs__unlink_rmdir(req, /*isrmdir*/0);
-}
-
-
 void fs__mkdir(uv_fs_t* req) {
   /* TODO: use req->mode. */
   if (CreateDirectoryW(req->file.pathw, NULL)) {
@@ -1240,7 +1182,7 @@ void fs__mktemp(uv_fs_t* req, uv__fs_mktemp_func func) {
   size_t len;
   uint64_t v;
   char* path;
-
+  
   path = (char*)req->path;
   len = wcslen(req->file.pathw);
   ep = req->file.pathw + len;
@@ -1651,12 +1593,12 @@ void fs__readdir(uv_fs_t* req) {
       goto error;
 
     /* Copy file type. */
-    if ((find_data->dwFileAttributes & FILE_ATTRIBUTE_DEVICE) != 0)
-      dent.d_type = UV__DT_CHAR;
+    if ((find_data->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
+      dent.d_type = UV__DT_DIR;
     else if ((find_data->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0)
       dent.d_type = UV__DT_LINK;
-    else if ((find_data->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
-      dent.d_type = UV__DT_DIR;
+    else if ((find_data->dwFileAttributes & FILE_ATTRIBUTE_DEVICE) != 0)
+      dent.d_type = UV__DT_CHAR;
     else
       dent.d_type = UV__DT_FILE;
 
@@ -1685,43 +1627,6 @@ void fs__closedir(uv_fs_t* req) {
   SET_REQ_RESULT(req, 0);
 }
 
-INLINE static fs__stat_path_return_t fs__stat_path(WCHAR* path,
-    uv_stat_t* statbuf, int do_lstat) {
-  FILE_STAT_BASIC_INFORMATION stat_info;
-
-  // Check if the new fast API is available.
-  if (!pGetFileInformationByName) {
-    return FS__STAT_PATH_TRY_SLOW;
-  }
-
-  // Check if the API call fails.
-  if (!pGetFileInformationByName(path, FileStatBasicByNameInfo, &stat_info,
-      sizeof(stat_info))) {
-    switch(GetLastError()) {
-      case ERROR_FILE_NOT_FOUND:
-      case ERROR_PATH_NOT_FOUND:
-      case ERROR_NOT_READY:
-      case ERROR_BAD_NET_NAME:
-        /* These errors aren't worth retrying with the slow path. */
-        return FS__STAT_PATH_ERROR;
-    }
-    return FS__STAT_PATH_TRY_SLOW;
-  }
-
-  // A file handle is needed to get st_size for links.
-  if ((stat_info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
-    return FS__STAT_PATH_TRY_SLOW;
-  }
-
-  if (stat_info.DeviceType == FILE_DEVICE_NULL) {
-    fs__stat_assign_statbuf_null(statbuf);
-    return FS__STAT_PATH_SUCCESS;
-  }
-
-  fs__stat_assign_statbuf(statbuf, stat_info, do_lstat);
-  return FS__STAT_PATH_SUCCESS;
-}
-
 INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf,
     int do_lstat) {
   size_t target_length = 0;
@@ -1730,7 +1635,6 @@ INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf,
   FILE_FS_VOLUME_INFORMATION volume_info;
   NTSTATUS nt_status;
   IO_STATUS_BLOCK io_status;
-  FILE_STAT_BASIC_INFORMATION stat_info;
 
   nt_status = pNtQueryVolumeInformationFile(handle,
                                             &io_status,
@@ -1746,7 +1650,13 @@ INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf,
 
   /* If it's NUL device set fields as reasonable as possible and return. */
   if (device_info.DeviceType == FILE_DEVICE_NULL) {
-    fs__stat_assign_statbuf_null(statbuf);
+    memset(statbuf, 0, sizeof(uv_stat_t));
+    statbuf->st_mode = _S_IFCHR;
+    statbuf->st_mode |= (_S_IREAD | _S_IWRITE) | ((_S_IREAD | _S_IWRITE) >> 3) |
+                        ((_S_IREAD | _S_IWRITE) >> 6);
+    statbuf->st_nlink = 1;
+    statbuf->st_blksize = 4096;    
+    statbuf->st_rdev = FILE_DEVICE_NULL << 16;
     return 0;
   }
 
@@ -1770,65 +1680,14 @@ INLINE static int fs__stat_handle(HANDLE handle, uv_stat_t* statbuf,
 
   /* Buffer overflow (a warning status code) is expected here. */
   if (io_status.Status == STATUS_NOT_IMPLEMENTED) {
-    stat_info.VolumeSerialNumber.QuadPart = 0;
+    statbuf->st_dev = 0;
   } else if (NT_ERROR(nt_status)) {
     SetLastError(pRtlNtStatusToDosError(nt_status));
     return -1;
   } else {
-    stat_info.VolumeSerialNumber.QuadPart = volume_info.VolumeSerialNumber;
-  }
-
-  stat_info.DeviceType = device_info.DeviceType;
-  stat_info.FileAttributes = file_info.BasicInformation.FileAttributes;
-  stat_info.NumberOfLinks = file_info.StandardInformation.NumberOfLinks;
-  stat_info.FileId.QuadPart =
-      file_info.InternalInformation.IndexNumber.QuadPart;
-  stat_info.ChangeTime.QuadPart =
-      file_info.BasicInformation.ChangeTime.QuadPart;
-  stat_info.CreationTime.QuadPart =
-      file_info.BasicInformation.CreationTime.QuadPart;
-  stat_info.LastAccessTime.QuadPart =
-      file_info.BasicInformation.LastAccessTime.QuadPart;
-  stat_info.LastWriteTime.QuadPart =
-      file_info.BasicInformation.LastWriteTime.QuadPart;
-  stat_info.AllocationSize.QuadPart =
-      file_info.StandardInformation.AllocationSize.QuadPart;
-
-  if (do_lstat &&
-      (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
-    /*
-     * If reading the link fails, the reparse point is not a symlink and needs
-     * to be treated as a regular file. The higher level lstat function will
-     * detect this failure and retry without do_lstat if appropriate.
-     */
-    if (fs__readlink_handle(handle, NULL, &target_length) != 0) {
-      fs__stat_assign_statbuf(statbuf, stat_info, do_lstat);
-      return -1;
-    }
-    stat_info.EndOfFile.QuadPart = target_length;
-  } else {
-    stat_info.EndOfFile.QuadPart =
-      file_info.StandardInformation.EndOfFile.QuadPart;
+    statbuf->st_dev = volume_info.VolumeSerialNumber;
   }
 
-  fs__stat_assign_statbuf(statbuf, stat_info, do_lstat);
-  return 0;
-}
-
-INLINE static void fs__stat_assign_statbuf_null(uv_stat_t* statbuf) {
-  memset(statbuf, 0, sizeof(uv_stat_t));
-  statbuf->st_mode = _S_IFCHR;
-  statbuf->st_mode |= (_S_IREAD | _S_IWRITE) | ((_S_IREAD | _S_IWRITE) >> 3) |
-                      ((_S_IREAD | _S_IWRITE) >> 6);
-  statbuf->st_nlink = 1;
-  statbuf->st_blksize = 4096;
-  statbuf->st_rdev = FILE_DEVICE_NULL << 16;
-}
-
-INLINE static void fs__stat_assign_statbuf(uv_stat_t* statbuf,
-    FILE_STAT_BASIC_INFORMATION stat_info, int do_lstat) {
-  statbuf->st_dev = stat_info.VolumeSerialNumber.QuadPart;
-
   /* Todo: st_mode should probably always be 0666 for everyone. We might also
    * want to report 0777 if the file is a .exe or a directory.
    *
@@ -1860,43 +1719,50 @@ INLINE static void fs__stat_assign_statbuf(uv_stat_t* statbuf,
   * target. Otherwise, reparse points must be treated as regular files.
   */
   if (do_lstat &&
-      (stat_info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
+      (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
+    /*
+     * If reading the link fails, the reparse point is not a symlink and needs
+     * to be treated as a regular file. The higher level lstat function will
+     * detect this failure and retry without do_lstat if appropriate.
+     */
+    if (fs__readlink_handle(handle, NULL, &target_length) != 0)
+      return -1;
     statbuf->st_mode |= S_IFLNK;
-    statbuf->st_size = stat_info.EndOfFile.QuadPart;
+    statbuf->st_size = target_length;
   }
 
   if (statbuf->st_mode == 0) {
-    if (stat_info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+    if (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
       statbuf->st_mode |= _S_IFDIR;
       statbuf->st_size = 0;
     } else {
       statbuf->st_mode |= _S_IFREG;
-      statbuf->st_size = stat_info.EndOfFile.QuadPart;
+      statbuf->st_size = file_info.StandardInformation.EndOfFile.QuadPart;
     }
   }
 
-  if (stat_info.FileAttributes & FILE_ATTRIBUTE_READONLY)
+  if (file_info.BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY)
     statbuf->st_mode |= _S_IREAD | (_S_IREAD >> 3) | (_S_IREAD >> 6);
   else
     statbuf->st_mode |= (_S_IREAD | _S_IWRITE) | ((_S_IREAD | _S_IWRITE) >> 3) |
                         ((_S_IREAD | _S_IWRITE) >> 6);
 
   uv__filetime_to_timespec(&statbuf->st_atim,
-                           stat_info.LastAccessTime.QuadPart);
+                           file_info.BasicInformation.LastAccessTime.QuadPart);
   uv__filetime_to_timespec(&statbuf->st_ctim,
-                           stat_info.ChangeTime.QuadPart);
+                           file_info.BasicInformation.ChangeTime.QuadPart);
   uv__filetime_to_timespec(&statbuf->st_mtim,
-                           stat_info.LastWriteTime.QuadPart);
+                           file_info.BasicInformation.LastWriteTime.QuadPart);
   uv__filetime_to_timespec(&statbuf->st_birthtim,
-                           stat_info.CreationTime.QuadPart);
+                           file_info.BasicInformation.CreationTime.QuadPart);
 
-  statbuf->st_ino = stat_info.FileId.QuadPart;
+  statbuf->st_ino = file_info.InternalInformation.IndexNumber.QuadPart;
 
   /* st_blocks contains the on-disk allocation size in 512-byte units. */
   statbuf->st_blocks =
-      (uint64_t) stat_info.AllocationSize.QuadPart >> 9;
+      (uint64_t) file_info.StandardInformation.AllocationSize.QuadPart >> 9;
 
-  statbuf->st_nlink = stat_info.NumberOfLinks;
+  statbuf->st_nlink = file_info.StandardInformation.NumberOfLinks;
 
   /* The st_blksize is supposed to be the 'optimal' number of bytes for reading
    * and writing to the disk. That is, for any definition of 'optimal' - it's
@@ -1928,6 +1794,8 @@ INLINE static void fs__stat_assign_statbuf(uv_stat_t* statbuf,
   statbuf->st_uid = 0;
   statbuf->st_rdev = 0;
   statbuf->st_gen = 0;
+
+  return 0;
 }
 
 
@@ -1949,17 +1817,6 @@ INLINE static DWORD fs__stat_impl_from_path(WCHAR* path,
   DWORD flags;
   DWORD ret;
 
-  // If new API exists, try to use it.
-  switch (fs__stat_path(path, statbuf, do_lstat)) {
-    case FS__STAT_PATH_SUCCESS:
-      return 0;
-    case FS__STAT_PATH_ERROR:
-      return GetLastError();
-    case FS__STAT_PATH_TRY_SLOW:
-      break;
-  }
-
-  // If the new API does not exist, use the old API.
   flags = FILE_FLAG_BACKUP_SEMANTICS;
   if (do_lstat)
     flags |= FILE_FLAG_OPEN_REPARSE_POINT;
@@ -2973,7 +2830,7 @@ static void uv__fs_done(struct uv__work* w, int status) {
   uv_fs_t* req;
 
   req = container_of(w, uv_fs_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   if (status == UV_ECANCELED) {
     assert(req->result == 0);
diff --git a/deps/uv/src/win/getaddrinfo.c b/deps/uv/src/win/getaddrinfo.c
index f20e10d49d9..8b8406ada8e 100644
--- a/deps/uv/src/win/getaddrinfo.c
+++ b/deps/uv/src/win/getaddrinfo.c
@@ -71,9 +71,10 @@ int uv__getaddrinfo_translate_error(int sys_err) {
   DECLSPEC_IMPORT void WSAAPI FreeAddrInfoW(PADDRINFOW pAddrInfo);
 #endif
 
-static size_t align_offset(size_t off, size_t alignment) {
-  return ((off + alignment - 1) / alignment) * alignment;
-}
+
+/* Adjust size value to be multiple of 4. Use to keep pointer aligned.
+ * Do we need different versions of this for different architectures? */
+#define ALIGNED_SIZE(X)     ((((X) + 3) >> 2) << 2)
 
 #ifndef NDIS_IF_MAX_STRING_SIZE
 #define NDIS_IF_MAX_STRING_SIZE IF_MAX_STRING_SIZE
@@ -102,7 +103,17 @@ static void uv__getaddrinfo_work(struct uv__work* w) {
  * Each size calculation is adjusted to avoid unaligned pointers.
  */
 static void uv__getaddrinfo_done(struct uv__work* w, int status) {
-  uv_getaddrinfo_t* req = container_of(w, uv_getaddrinfo_t, work_req);
+  uv_getaddrinfo_t* req;
+  size_t addrinfo_len = 0;
+  ssize_t name_len = 0;
+  size_t addrinfo_struct_len = ALIGNED_SIZE(sizeof(struct addrinfo));
+  struct addrinfoW* addrinfow_ptr;
+  struct addrinfo* addrinfo_ptr;
+  char* alloc_ptr = NULL;
+  char* cur_ptr = NULL;
+  int r;
+
+  req = container_of(w, uv_getaddrinfo_t, work_req);
 
   /* release input parameter memory */
   uv__free(req->alloc);
@@ -115,44 +126,34 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
   }
 
   if (req->retcode == 0) {
-    char* alloc_ptr = NULL;
-    size_t cur_off = 0;
-    size_t addrinfo_len;
     /* Convert addrinfoW to addrinfo. First calculate required length. */
-    struct addrinfoW* addrinfow_ptr = req->addrinfow;
+    addrinfow_ptr = req->addrinfow;
     while (addrinfow_ptr != NULL) {
-      cur_off = align_offset(cur_off, sizeof(void*));
-      cur_off += sizeof(struct addrinfo);
-      /* TODO: This alignment could be smaller, if we could
-	           portably get the alignment for sockaddr. */
-      cur_off = align_offset(cur_off, sizeof(void*));
-      cur_off += addrinfow_ptr->ai_addrlen;
+      addrinfo_len += addrinfo_struct_len +
+          ALIGNED_SIZE(addrinfow_ptr->ai_addrlen);
       if (addrinfow_ptr->ai_canonname != NULL) {
-        ssize_t name_len =
-            uv_utf16_length_as_wtf8(addrinfow_ptr->ai_canonname, -1);
+        name_len = uv_utf16_length_as_wtf8(addrinfow_ptr->ai_canonname, -1);
         if (name_len < 0) {
           req->retcode = name_len;
           goto complete;
         }
-        cur_off += name_len + 1;
+        addrinfo_len += ALIGNED_SIZE(name_len + 1);
       }
       addrinfow_ptr = addrinfow_ptr->ai_next;
     }
 
     /* allocate memory for addrinfo results */
-    addrinfo_len = cur_off;
-    alloc_ptr = uv__malloc(addrinfo_len);
+    alloc_ptr = (char*)uv__malloc(addrinfo_len);
 
     /* do conversions */
     if (alloc_ptr != NULL) {
-      struct addrinfo *addrinfo_ptr = (struct addrinfo *)alloc_ptr;
-      cur_off = 0;
+      cur_ptr = alloc_ptr;
       addrinfow_ptr = req->addrinfow;
 
-      for (;;) {
-        cur_off += sizeof(struct addrinfo);
-        assert(cur_off <= addrinfo_len);
+      while (addrinfow_ptr != NULL) {
         /* copy addrinfo struct data */
+        assert(cur_ptr + addrinfo_struct_len <= alloc_ptr + addrinfo_len);
+        addrinfo_ptr = (struct addrinfo*)cur_ptr;
         addrinfo_ptr->ai_family = addrinfow_ptr->ai_family;
         addrinfo_ptr->ai_socktype = addrinfow_ptr->ai_socktype;
         addrinfo_ptr->ai_protocol = addrinfow_ptr->ai_protocol;
@@ -162,37 +163,35 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
         addrinfo_ptr->ai_addr = NULL;
         addrinfo_ptr->ai_next = NULL;
 
+        cur_ptr += addrinfo_struct_len;
+
         /* copy sockaddr */
         if (addrinfo_ptr->ai_addrlen > 0) {
-          cur_off = align_offset(cur_off, sizeof(void *));
-          addrinfo_ptr->ai_addr = (struct sockaddr *)(alloc_ptr + cur_off);
-          cur_off += addrinfo_ptr->ai_addrlen;
-          assert(cur_off <= addrinfo_len);
-          memcpy(addrinfo_ptr->ai_addr,
-	             addrinfow_ptr->ai_addr,
-                 addrinfo_ptr->ai_addrlen);
+          assert(cur_ptr + addrinfo_ptr->ai_addrlen <=
+                 alloc_ptr + addrinfo_len);
+          memcpy(cur_ptr, addrinfow_ptr->ai_addr, addrinfo_ptr->ai_addrlen);
+          addrinfo_ptr->ai_addr = (struct sockaddr*)cur_ptr;
+          cur_ptr += ALIGNED_SIZE(addrinfo_ptr->ai_addrlen);
         }
 
         /* convert canonical name to UTF-8 */
         if (addrinfow_ptr->ai_canonname != NULL) {
-          ssize_t name_len = addrinfo_len - cur_off;
-          addrinfo_ptr->ai_canonname = alloc_ptr + cur_off;
-          int r = uv__copy_utf16_to_utf8(addrinfow_ptr->ai_canonname,
-                                         -1,
-                                         addrinfo_ptr->ai_canonname,
-                                         (size_t*)&name_len);
+          name_len = alloc_ptr + addrinfo_len - cur_ptr;
+          r = uv__copy_utf16_to_utf8(addrinfow_ptr->ai_canonname,
+                                     -1,
+                                     cur_ptr,
+                                     (size_t*)&name_len);
           assert(r == 0);
-          cur_off += name_len + 1;
-          assert(cur_off <= addrinfo_len);
+          addrinfo_ptr->ai_canonname = cur_ptr;
+          cur_ptr += ALIGNED_SIZE(name_len + 1);
         }
+        assert(cur_ptr <= alloc_ptr + addrinfo_len);
 
         /* set next ptr */
         addrinfow_ptr = addrinfow_ptr->ai_next;
-        if (addrinfow_ptr == NULL)
-          break;
-        cur_off = align_offset(cur_off, sizeof(void *));
-        addrinfo_ptr = (struct addrinfo *)(alloc_ptr + cur_off);
-        addrinfo_ptr->ai_next = addrinfo_ptr;
+        if (addrinfow_ptr != NULL) {
+          addrinfo_ptr->ai_next = (struct addrinfo*)cur_ptr;
+        }
       }
       req->addrinfo = (struct addrinfo*)alloc_ptr;
     } else {
@@ -207,7 +206,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {
   }
 
 complete:
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
 
   /* finally do callback with converted result */
   if (req->getaddrinfo_cb)
@@ -243,12 +242,10 @@ int uv_getaddrinfo(uv_loop_t* loop,
                    const char* service,
                    const struct addrinfo* hints) {
   char hostname_ascii[256];
-  size_t off = 0;
   size_t nodesize = 0;
   size_t servicesize = 0;
-  size_t serviceoff = 0;
   size_t hintssize = 0;
-  size_t hintoff = 0;
+  char* alloc_ptr = NULL;
   ssize_t rc;
 
   if (req == NULL || (node == NULL && service == NULL)) {
@@ -271,7 +268,6 @@ int uv_getaddrinfo(uv_loop_t* loop,
       return rc;
     nodesize = strlen(hostname_ascii) + 1;
     node = hostname_ascii;
-    off += nodesize * sizeof(WCHAR);
   }
 
   if (service != NULL) {
@@ -279,28 +275,27 @@ int uv_getaddrinfo(uv_loop_t* loop,
     if (rc < 0)
        return rc;
     servicesize = rc;
-    off = align_offset(off, sizeof(WCHAR));
-    serviceoff = off;
-    off += servicesize * sizeof(WCHAR);
   }
-
   if (hints != NULL) {
-    off = align_offset(off, sizeof(void *));
-    hintoff = off;
-    hintssize = sizeof(struct addrinfoW);
-    off += hintssize;
+    hintssize = ALIGNED_SIZE(sizeof(struct addrinfoW));
   }
 
   /* allocate memory for inputs, and partition it as needed */
-  req->alloc = uv__malloc(off);
-  if (!req->alloc)
+  alloc_ptr = uv__malloc(ALIGNED_SIZE(nodesize * sizeof(WCHAR)) +
+                         ALIGNED_SIZE(servicesize * sizeof(WCHAR)) +
+                         hintssize);
+  if (!alloc_ptr)
     return UV_ENOMEM;
 
+  /* save alloc_ptr now so we can free if error */
+  req->alloc = (void*) alloc_ptr;
+
   /* Convert node string to UTF16 into allocated memory and save pointer in the
    * request. The node here has been converted to ascii. */
   if (node != NULL) {
-    req->node = (WCHAR*) req->alloc;
-    uv_wtf8_to_utf16(node, req->node, nodesize);
+    req->node = (WCHAR*) alloc_ptr;
+    uv_wtf8_to_utf16(node, (WCHAR*) alloc_ptr, nodesize);
+    alloc_ptr += ALIGNED_SIZE(nodesize * sizeof(WCHAR));
   } else {
     req->node = NULL;
   }
@@ -308,15 +303,16 @@ int uv_getaddrinfo(uv_loop_t* loop,
   /* Convert service string to UTF16 into allocated memory and save pointer in
    * the req. */
   if (service != NULL) {
-    req->service = (WCHAR*) ((char*) req->alloc + serviceoff);
-    uv_wtf8_to_utf16(service, req->service, servicesize);
+    req->service = (WCHAR*) alloc_ptr;
+    uv_wtf8_to_utf16(service, (WCHAR*) alloc_ptr, servicesize);
+    alloc_ptr += ALIGNED_SIZE(servicesize * sizeof(WCHAR));
   } else {
     req->service = NULL;
   }
 
   /* copy hints to allocated memory and save pointer in req */
   if (hints != NULL) {
-    req->addrinfow = (struct addrinfoW*) ((char*) req->alloc + hintoff);
+    req->addrinfow = (struct addrinfoW*) alloc_ptr;
     req->addrinfow->ai_family = hints->ai_family;
     req->addrinfow->ai_socktype = hints->ai_socktype;
     req->addrinfow->ai_protocol = hints->ai_protocol;
@@ -329,7 +325,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
     req->addrinfow = NULL;
   }
 
-  uv__req_register(loop);
+  uv__req_register(loop, req);
 
   if (getaddrinfo_cb) {
     uv__work_submit(loop,
diff --git a/deps/uv/src/win/getnameinfo.c b/deps/uv/src/win/getnameinfo.c
index 695549580d2..32863176ef6 100644
--- a/deps/uv/src/win/getnameinfo.c
+++ b/deps/uv/src/win/getnameinfo.c
@@ -82,7 +82,7 @@ static void uv__getnameinfo_done(struct uv__work* w, int status) {
   char* service;
 
   req = container_of(w, uv_getnameinfo_t, work_req);
-  uv__req_unregister(req->loop);
+  uv__req_unregister(req->loop, req);
   host = service = NULL;
 
   if (status == UV_ECANCELED) {
@@ -124,7 +124,7 @@ int uv_getnameinfo(uv_loop_t* loop,
   }
 
   UV_REQ_INIT(req, UV_GETNAMEINFO);
-  uv__req_register(loop);
+  uv__req_register(loop, req);
 
   req->getnameinfo_cb = getnameinfo_cb;
   req->flags = flags;
diff --git a/deps/uv/src/win/internal.h b/deps/uv/src/win/internal.h
index be408af6661..867dea5e0ed 100644
--- a/deps/uv/src/win/internal.h
+++ b/deps/uv/src/win/internal.h
@@ -330,6 +330,4 @@ void uv__wake_all_loops(void);
  */
 void uv__init_detect_system_wakeup(void);
 
-int uv_translate_write_sys_error(int sys_errno);
-
 #endif /* UV_WIN_INTERNAL_H_ */
diff --git a/deps/uv/src/win/pipe.c b/deps/uv/src/win/pipe.c
index d46ecb9fc70..3c8abe1c28c 100644
--- a/deps/uv/src/win/pipe.c
+++ b/deps/uv/src/win/pipe.c
@@ -106,8 +106,8 @@ static int includes_nul(const char *s, size_t n) {
 }
 
 
-static void uv__unique_pipe_name(unsigned long long ptr, char* name, size_t size) {
-  snprintf(name, size, "\\\\?\\pipe\\uv\\%llu-%lu", ptr, GetCurrentProcessId());
+static void uv__unique_pipe_name(char* ptr, char* name, size_t size) {
+  snprintf(name, size, "\\\\?\\pipe\\uv\\%p-%lu", ptr, GetCurrentProcessId());
 }
 
 
@@ -208,7 +208,7 @@ static void close_pipe(uv_pipe_t* pipe) {
 
 static int uv__pipe_server(
     HANDLE* pipeHandle_ptr, DWORD access,
-    char* name, size_t nameSize, unsigned long long random) {
+    char* name, size_t nameSize, char* random) {
   HANDLE pipeHandle;
   int err;
 
@@ -249,7 +249,7 @@ static int uv__pipe_server(
 static int uv__create_pipe_pair(
     HANDLE* server_pipe_ptr, HANDLE* client_pipe_ptr,
     unsigned int server_flags, unsigned int client_flags,
-    int inherit_client, unsigned long long random) {
+    int inherit_client, char* random) {
   /* allowed flags are: UV_READABLE_PIPE | UV_WRITABLE_PIPE | UV_NONBLOCK_PIPE */
   char pipe_name[64];
   SECURITY_ATTRIBUTES sa;
@@ -357,12 +357,7 @@ int uv_pipe(uv_file fds[2], int read_flags, int write_flags) {
   /* TODO: better source of local randomness than &fds? */
   read_flags |= UV_READABLE_PIPE;
   write_flags |= UV_WRITABLE_PIPE;
-  err = uv__create_pipe_pair(&readh,
-                             &writeh,
-                             read_flags,
-                             write_flags,
-                             0,
-                             (uintptr_t) &fds[0]);
+  err = uv__create_pipe_pair(&readh, &writeh, read_flags, write_flags, 0, (char*) &fds[0]);
   if (err != 0)
     return err;
   temp[0] = _open_osfhandle((intptr_t) readh, 0);
@@ -426,7 +421,7 @@ int uv__create_stdio_pipe_pair(uv_loop_t* loop,
   }
 
   err = uv__create_pipe_pair(&server_pipe, &client_pipe,
-          server_flags, client_flags, 1, (uintptr_t) server_pipe);
+          server_flags, client_flags, 1, (char*) server_pipe);
   if (err)
     goto error;
 
@@ -672,10 +667,15 @@ void uv__pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {
     }
     handle->pipe.conn.ipc_xfer_queue_length = 0;
 
-    assert(handle->read_req.wait_handle == INVALID_HANDLE_VALUE);
-    if (handle->read_req.event_handle != NULL) {
-      CloseHandle(handle->read_req.event_handle);
-      handle->read_req.event_handle = NULL;
+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
+      if (handle->read_req.wait_handle != INVALID_HANDLE_VALUE) {
+        UnregisterWait(handle->read_req.wait_handle);
+        handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
+      }
+      if (handle->read_req.event_handle != NULL) {
+        CloseHandle(handle->read_req.event_handle);
+        handle->read_req.event_handle = NULL;
+      }
     }
 
     if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE)
@@ -868,7 +868,7 @@ void uv_pipe_connect(uv_connect_t* req,
     SET_REQ_ERROR(req, err);
     uv__insert_pending_req(loop, (uv_req_t*) req);
     handle->reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
   }
 }
 
@@ -959,7 +959,7 @@ int uv_pipe_connect2(uv_connect_t* req,
         goto error;
       }
 
-      REGISTER_HANDLE_REQ(loop, handle);
+      REGISTER_HANDLE_REQ(loop, handle, req);
       handle->reqs_pending++;
 
       return 0;
@@ -974,7 +974,7 @@ int uv_pipe_connect2(uv_connect_t* req,
   SET_REQ_SUCCESS(req);
   uv__insert_pending_req(loop, (uv_req_t*) req);
   handle->reqs_pending++;
-  REGISTER_HANDLE_REQ(loop, handle);
+  REGISTER_HANDLE_REQ(loop, handle, req);
   return 0;
 
 error:
@@ -992,7 +992,7 @@ error:
   SET_REQ_ERROR(req, err);
   uv__insert_pending_req(loop, (uv_req_t*) req);
   handle->reqs_pending++;
-  REGISTER_HANDLE_REQ(loop, handle);
+  REGISTER_HANDLE_REQ(loop, handle, req);
   return 0;
 }
 
@@ -1417,12 +1417,13 @@ static void uv__pipe_queue_read(uv_loop_t* loop, uv_pipe_t* handle) {
     }
 
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
-      assert(req->wait_handle == INVALID_HANDLE_VALUE);
-      if (!RegisterWaitForSingleObject(&req->wait_handle,
-          req->event_handle, post_completion_read_wait, (void*) req,
-          INFINITE, WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE)) {
-        SET_REQ_ERROR(req, GetLastError());
-        goto error;
+      if (req->wait_handle == INVALID_HANDLE_VALUE) {
+        if (!RegisterWaitForSingleObject(&req->wait_handle,
+            req->event_handle, post_completion_read_wait, (void*) req,
+            INFINITE, WT_EXECUTEINWAITTHREAD)) {
+          SET_REQ_ERROR(req, GetLastError());
+          goto error;
+        }
       }
     }
   }
@@ -1450,16 +1451,16 @@ int uv__pipe_read_start(uv_pipe_t* handle,
   handle->read_cb = read_cb;
   handle->alloc_cb = alloc_cb;
 
-  if (handle->read_req.event_handle == NULL) {
-    handle->read_req.event_handle = CreateEvent(NULL, 0, 0, NULL);
-    if (handle->read_req.event_handle == NULL) {
-      uv_fatal_error(GetLastError(), "CreateEvent");
-    }
-  }
-
   /* If reading was stopped and then started again, there could still be a read
    * request pending. */
   if (!(handle->flags & UV_HANDLE_READ_PENDING)) {
+    if (handle->flags & UV_HANDLE_EMULATE_IOCP &&
+        handle->read_req.event_handle == NULL) {
+      handle->read_req.event_handle = CreateEvent(NULL, 0, 0, NULL);
+      if (handle->read_req.event_handle == NULL) {
+        uv_fatal_error(GetLastError(), "CreateEvent");
+      }
+    }
     uv__pipe_queue_read(loop, handle);
   }
 
@@ -1637,7 +1638,7 @@ static int uv__pipe_write_data(uv_loop_t* loop,
       req->u.io.queued_bytes = 0;
     }
 
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     handle->reqs_pending++;
     handle->stream.conn.write_reqs_pending++;
     POST_COMPLETION_FOR_REQ(loop, req);
@@ -1685,7 +1686,7 @@ static int uv__pipe_write_data(uv_loop_t* loop,
     CloseHandle(req->event_handle);
     req->event_handle = NULL;
 
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     handle->reqs_pending++;
     handle->stream.conn.write_reqs_pending++;
     return 0;
@@ -1712,13 +1713,13 @@ static int uv__pipe_write_data(uv_loop_t* loop,
     if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
       if (!RegisterWaitForSingleObject(&req->wait_handle,
           req->event_handle, post_completion_write_wait, (void*) req,
-          INFINITE, WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE)) {
+          INFINITE, WT_EXECUTEINWAITTHREAD)) {
         return GetLastError();
       }
     }
   }
 
-  REGISTER_HANDLE_REQ(loop, handle);
+  REGISTER_HANDLE_REQ(loop, handle, req);
   handle->reqs_pending++;
   handle->stream.conn.write_reqs_pending++;
 
@@ -1888,7 +1889,7 @@ static void uv__pipe_read_error(uv_loop_t* loop, uv_pipe_t* handle, int error,
 
 
 static void uv__pipe_read_error_or_eof(uv_loop_t* loop, uv_pipe_t* handle,
-    DWORD error, uv_buf_t buf) {
+    int error, uv_buf_t buf) {
   if (error == ERROR_BROKEN_PIPE) {
     uv__pipe_read_eof(loop, handle, buf);
   } else {
@@ -1918,25 +1919,17 @@ static void uv__pipe_queue_ipc_xfer_info(
 /* Read an exact number of bytes from a pipe. If an error or end-of-file is
  * encountered before the requested number of bytes are read, an error is
  * returned. */
-static DWORD uv__pipe_read_exactly(uv_pipe_t* handle, void* buffer, DWORD count) {
-  uv_read_t* req;
-  DWORD bytes_read;
-  DWORD bytes_read_now;
+static int uv__pipe_read_exactly(HANDLE h, void* buffer, DWORD count) {
+  DWORD bytes_read, bytes_read_now;
 
   bytes_read = 0;
   while (bytes_read < count) {
-    req = &handle->read_req;
-    memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
-    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);
-    if (!ReadFile(handle->handle,
+    if (!ReadFile(h,
                   (char*) buffer + bytes_read,
                   count - bytes_read,
                   &bytes_read_now,
-                  &req->u.io.overlapped)) {
-      if (GetLastError() != ERROR_IO_PENDING)
-        return GetLastError();
-      if (!GetOverlappedResult(handle->handle, &req->u.io.overlapped, &bytes_read_now, TRUE))
-        return GetLastError();
+                  NULL)) {
+      return GetLastError();
     }
 
     bytes_read += bytes_read_now;
@@ -1947,19 +1940,16 @@ static DWORD uv__pipe_read_exactly(uv_pipe_t* handle, void* buffer, DWORD count)
 }
 
 
-static int uv__pipe_read_data(uv_loop_t* loop,
-                              uv_pipe_t* handle,
-                              DWORD* bytes_read, /* inout argument */
-                              DWORD max_bytes) {
+static DWORD uv__pipe_read_data(uv_loop_t* loop,
+                                uv_pipe_t* handle,
+                                DWORD suggested_bytes,
+                                DWORD max_bytes) {
+  DWORD bytes_read;
   uv_buf_t buf;
-  uv_read_t* req;
-  DWORD r;
-  DWORD bytes_available;
-  int more;
 
   /* Ask the user for a buffer to read data into. */
   buf = uv_buf_init(NULL, 0);
-  handle->alloc_cb((uv_handle_t*) handle, *bytes_read, &buf);
+  handle->alloc_cb((uv_handle_t*) handle, suggested_bytes, &buf);
   if (buf.base == NULL || buf.len == 0) {
     handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &buf);
     return 0; /* Break out of read loop. */
@@ -1968,77 +1958,33 @@ static int uv__pipe_read_data(uv_loop_t* loop,
   /* Ensure we read at most the smaller of:
    *   (a) the length of the user-allocated buffer.
    *   (b) the maximum data length as specified by the `max_bytes` argument.
-   *   (c) the amount of data that can be read non-blocking
    */
   if (max_bytes > buf.len)
     max_bytes = buf.len;
 
-  if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {
-    /* The user failed to supply a pipe that can be used non-blocking or with
-     * threads. Try to estimate the amount of data that is safe to read without
-     * blocking, in a race-y way however. */
-    bytes_available = 0;
-    if (!PeekNamedPipe(handle->handle, NULL, 0, NULL, &bytes_available, NULL)) {
-      r = GetLastError();
-    } else {
-      if (max_bytes > bytes_available)
-        max_bytes = bytes_available;
-      *bytes_read = 0;
-      if (max_bytes == 0 || ReadFile(handle->handle, buf.base, max_bytes, bytes_read, NULL))
-        r = ERROR_SUCCESS;
-      else
-        r = GetLastError();
-    }
-    more = max_bytes < bytes_available;
-  } else {
-    /* Read into the user buffer.
-     * Prepare an Event so that we can cancel if it doesn't complete immediately.
-     */
-    req = &handle->read_req;
-    memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));
-    req->u.io.overlapped.hEvent = (HANDLE) ((uintptr_t) req->event_handle | 1);
-    if (ReadFile(handle->handle, buf.base, max_bytes, bytes_read, &req->u.io.overlapped)) {
-      r = ERROR_SUCCESS;
-    } else {
-      r = GetLastError();
-      *bytes_read = 0;
-      if (r == ERROR_IO_PENDING) {
-        r = CancelIoEx(handle->handle, &req->u.io.overlapped);
-        assert(r || GetLastError() == ERROR_NOT_FOUND);
-        if (GetOverlappedResult(handle->handle, &req->u.io.overlapped, bytes_read, TRUE)) {
-          r = ERROR_SUCCESS;
-        } else {
-          r = GetLastError();
-          *bytes_read = 0;
-        }
-      }
-    }
-    more = *bytes_read == max_bytes;
+  /* Read into the user buffer. */
+  if (!ReadFile(handle->handle, buf.base, max_bytes, &bytes_read, NULL)) {
+    uv__pipe_read_error_or_eof(loop, handle, GetLastError(), buf);
+    return 0; /* Break out of read loop. */
   }
 
   /* Call the read callback. */
-  if (r == ERROR_SUCCESS || r == ERROR_OPERATION_ABORTED)
-    handle->read_cb((uv_stream_t*) handle, *bytes_read, &buf);
-  else
-    uv__pipe_read_error_or_eof(loop, handle, r, buf);
+  handle->read_cb((uv_stream_t*) handle, bytes_read, &buf);
 
-  return more;
+  return bytes_read;
 }
 
 
-static int uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {
-  uint32_t* data_remaining;
-  DWORD err;
-  DWORD more;
-  DWORD bytes_read;
-
-  data_remaining = &handle->pipe.conn.ipc_data_frame.payload_remaining;
+static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {
+  uint32_t* data_remaining = &handle->pipe.conn.ipc_data_frame.payload_remaining;
+  int err;
 
   if (*data_remaining > 0) {
     /* Read frame data payload. */
-    bytes_read = *data_remaining;
-    more = uv__pipe_read_data(loop, handle, &bytes_read, bytes_read);
+    DWORD bytes_read =
+        uv__pipe_read_data(loop, handle, *data_remaining, *data_remaining);
     *data_remaining -= bytes_read;
+    return bytes_read;
 
   } else {
     /* Start of a new IPC frame. */
@@ -2049,7 +1995,7 @@ static int uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {
 
     /* Read the IPC frame header. */
     err = uv__pipe_read_exactly(
-        handle, &frame_header, sizeof frame_header);
+        handle->handle, &frame_header, sizeof frame_header);
     if (err)
       goto error;
 
@@ -2085,23 +2031,20 @@ static int uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {
 
     /* If no socket xfer info follows, return here. Data will be read in a
      * subsequent invocation of uv__pipe_read_ipc(). */
-    if (xfer_type != UV__IPC_SOCKET_XFER_NONE) {
-      /* Read transferred socket information. */
-      err = uv__pipe_read_exactly(handle, &xfer_info, sizeof xfer_info);
-      if (err)
-        goto error;
+    if (xfer_type == UV__IPC_SOCKET_XFER_NONE)
+      return sizeof frame_header; /* Number of bytes read. */
 
-      /* Store the pending socket info. */
-      uv__pipe_queue_ipc_xfer_info(handle, xfer_type, &xfer_info);
-    }
-  }
+    /* Read transferred socket information. */
+    err = uv__pipe_read_exactly(handle->handle, &xfer_info, sizeof xfer_info);
+    if (err)
+      goto error;
 
-  /* Return whether the caller should immediately try another read call to get
-   * more data. Calling uv__pipe_read_exactly will hang if there isn't data
-   * available, so we cannot do this unless we are guaranteed not to reach that.
-   */
-  more = *data_remaining > 0;
-  return more;
+    /* Store the pending socket info. */
+    uv__pipe_queue_ipc_xfer_info(handle, xfer_type, &xfer_info);
+
+    /* Return number of bytes read. */
+    return sizeof frame_header + sizeof xfer_info;
+  }
 
 invalid:
   /* Invalid frame. */
@@ -2116,20 +2059,12 @@ error:
 void uv__process_pipe_read_req(uv_loop_t* loop,
                                uv_pipe_t* handle,
                                uv_req_t* req) {
-  DWORD err;
-  DWORD more;
-  DWORD bytes_requested;
   assert(handle->type == UV_NAMED_PIPE);
 
   handle->flags &= ~(UV_HANDLE_READ_PENDING | UV_HANDLE_CANCELLATION_PENDING);
   DECREASE_PENDING_REQ_COUNT(handle);
   eof_timer_stop(handle);
 
-  if (handle->read_req.wait_handle != INVALID_HANDLE_VALUE) {
-    UnregisterWait(handle->read_req.wait_handle);
-    handle->read_req.wait_handle = INVALID_HANDLE_VALUE;
-  }
-
   /* At this point, we're done with bookkeeping. If the user has stopped
    * reading the pipe in the meantime, there is nothing left to do, since there
    * is no callback that we can call. */
@@ -2138,7 +2073,7 @@ void uv__process_pipe_read_req(uv_loop_t* loop,
 
   if (!REQ_SUCCESS(req)) {
     /* An error occurred doing the zero-read. */
-    err = GET_REQ_ERROR(req);
+    DWORD err = GET_REQ_ERROR(req);
 
     /* If the read was cancelled by uv__pipe_interrupt_read(), the request may
      * indicate an ERROR_OPERATION_ABORTED error. This error isn't relevant to
@@ -2149,18 +2084,34 @@ void uv__process_pipe_read_req(uv_loop_t* loop,
   } else {
     /* The zero-read completed without error, indicating there is data
      * available in the kernel buffer. */
-    while (handle->flags & UV_HANDLE_READING) {
-      bytes_requested = 65536;
+    DWORD avail;
+
+    /* Get the number of bytes available. */
+    avail = 0;
+    if (!PeekNamedPipe(handle->handle, NULL, 0, NULL, &avail, NULL))
+      uv__pipe_read_error_or_eof(loop, handle, GetLastError(), uv_null_buf_);
+
+    /* Read until we've either read all the bytes available, or the 'reading'
+     * flag is cleared. */
+    while (avail > 0 && handle->flags & UV_HANDLE_READING) {
       /* Depending on the type of pipe, read either IPC frames or raw data. */
-      if (handle->ipc)
-          more = uv__pipe_read_ipc(loop, handle);
-      else
-          more = uv__pipe_read_data(loop, handle, &bytes_requested, INT32_MAX);
+      DWORD bytes_read =
+          handle->ipc ? uv__pipe_read_ipc(loop, handle)
+                      : uv__pipe_read_data(loop, handle, avail, (DWORD) -1);
 
       /* If no bytes were read, treat this as an indication that an error
        * occurred, and break out of the read loop. */
-      if (more == 0)
+      if (bytes_read == 0)
+        break;
+
+      /* It is possible that more bytes were read than we thought were
+       * available. To prevent `avail` from underflowing, break out of the loop
+       * if this is the case. */
+      if (bytes_read > avail)
         break;
+
+      /* Recompute the number of bytes available. */
+      avail -= bytes_read;
     }
   }
 
@@ -2181,15 +2132,17 @@ void uv__process_pipe_write_req(uv_loop_t* loop, uv_pipe_t* handle,
   assert(handle->write_queue_size >= req->u.io.queued_bytes);
   handle->write_queue_size -= req->u.io.queued_bytes;
 
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
-  if (req->wait_handle != INVALID_HANDLE_VALUE) {
-    UnregisterWait(req->wait_handle);
-    req->wait_handle = INVALID_HANDLE_VALUE;
-  }
-  if (req->event_handle) {
-    CloseHandle(req->event_handle);
-    req->event_handle = NULL;
+  if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
+    if (req->wait_handle != INVALID_HANDLE_VALUE) {
+      UnregisterWait(req->wait_handle);
+      req->wait_handle = INVALID_HANDLE_VALUE;
+    }
+    if (req->event_handle) {
+      CloseHandle(req->event_handle);
+      req->event_handle = NULL;
+    }
   }
 
   err = GET_REQ_ERROR(req);
@@ -2266,7 +2219,7 @@ void uv__process_pipe_connect_req(uv_loop_t* loop, uv_pipe_t* handle,
 
   assert(handle->type == UV_NAMED_PIPE);
 
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   err = 0;
   if (REQ_SUCCESS(req)) {
@@ -2298,7 +2251,7 @@ void uv__process_pipe_shutdown_req(uv_loop_t* loop, uv_pipe_t* handle,
 
   /* Clear the shutdown_req field so we don't go here again. */
   handle->stream.conn.shutdown_req = NULL;
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   if (handle->flags & UV_HANDLE_CLOSING) {
     /* Already closing. Cancel the shutdown. */
diff --git a/deps/uv/src/win/process-stdio.c b/deps/uv/src/win/process-stdio.c
index 181db92ea30..0db35723731 100644
--- a/deps/uv/src/win/process-stdio.c
+++ b/deps/uv/src/win/process-stdio.c
@@ -46,12 +46,12 @@
 #define CHILD_STDIO_CRT_FLAGS(buffer, fd)           \
     *((unsigned char*) (buffer) + sizeof(int) + fd)
 
-#define CHILD_STDIO_HANDLE(buffer, fd)           \
-    ((void*) ((unsigned char*) (buffer) +        \
-              sizeof(int) +                      \
-              sizeof(unsigned char) *            \
-              CHILD_STDIO_COUNT((buffer)) +      \
-              sizeof(HANDLE) * (fd)))
+#define CHILD_STDIO_HANDLE(buffer, fd)              \
+    *((HANDLE*) ((unsigned char*) (buffer) +        \
+                 sizeof(int) +                      \
+                 sizeof(unsigned char) *            \
+                 CHILD_STDIO_COUNT((buffer)) +      \
+                 sizeof(HANDLE) * (fd)))
 
 
 /* CRT file descriptor mode flags */
@@ -194,7 +194,7 @@ int uv__stdio_create(uv_loop_t* loop,
   CHILD_STDIO_COUNT(buffer) = count;
   for (i = 0; i < count; i++) {
     CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;
-    memset(CHILD_STDIO_HANDLE(buffer, i), 0xFF, sizeof(HANDLE));
+    CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;
   }
 
   for (i = 0; i < count; i++) {
@@ -215,15 +215,14 @@ int uv__stdio_create(uv_loop_t* loop,
          * handles in the stdio buffer are initialized with.
          * INVALID_HANDLE_VALUE, which should be okay. */
         if (i <= 2) {
-          HANDLE nul;
           DWORD access = (i == 0) ? FILE_GENERIC_READ :
                                     FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES;
 
-          err = uv__create_nul_handle(&nul, access);
+          err = uv__create_nul_handle(&CHILD_STDIO_HANDLE(buffer, i),
+                                      access);
           if (err)
             goto error;
 
-		  memcpy(CHILD_STDIO_HANDLE(buffer, i), &nul, sizeof(HANDLE));
           CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;
         }
         break;
@@ -248,7 +247,7 @@ int uv__stdio_create(uv_loop_t* loop,
         if (err)
           goto error;
 
-		memcpy(CHILD_STDIO_HANDLE(buffer, i), &child_pipe, sizeof(HANDLE));
+        CHILD_STDIO_HANDLE(buffer, i) = child_pipe;
         CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;
         break;
       }
@@ -264,7 +263,7 @@ int uv__stdio_create(uv_loop_t* loop,
            * error. */
           if (fdopt.data.fd <= 2 && err == ERROR_INVALID_HANDLE) {
             CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;
-            memset(CHILD_STDIO_HANDLE(buffer, i), 0xFF, sizeof(HANDLE));
+            CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;
             break;
           }
           goto error;
@@ -299,7 +298,7 @@ int uv__stdio_create(uv_loop_t* loop,
             return -1;
         }
 
-		memcpy(CHILD_STDIO_HANDLE(buffer, i), &child_handle, sizeof(HANDLE));
+        CHILD_STDIO_HANDLE(buffer, i) = child_handle;
         break;
       }
 
@@ -335,7 +334,7 @@ int uv__stdio_create(uv_loop_t* loop,
         if (err)
           goto error;
 
-		memcpy(CHILD_STDIO_HANDLE(buffer, i), &child_handle, sizeof(HANDLE));
+        CHILD_STDIO_HANDLE(buffer, i) = child_handle;
         CHILD_STDIO_CRT_FLAGS(buffer, i) = crt_flags;
         break;
       }
@@ -360,7 +359,7 @@ void uv__stdio_destroy(BYTE* buffer) {
 
   count = CHILD_STDIO_COUNT(buffer);
   for (i = 0; i < count; i++) {
-    HANDLE handle = uv__stdio_handle(buffer, i);
+    HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);
     if (handle != INVALID_HANDLE_VALUE) {
       CloseHandle(handle);
     }
@@ -375,7 +374,7 @@ void uv__stdio_noinherit(BYTE* buffer) {
 
   count = CHILD_STDIO_COUNT(buffer);
   for (i = 0; i < count; i++) {
-    HANDLE handle = uv__stdio_handle(buffer, i);
+    HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);
     if (handle != INVALID_HANDLE_VALUE) {
       SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);
     }
@@ -413,7 +412,5 @@ WORD uv__stdio_size(BYTE* buffer) {
 
 
 HANDLE uv__stdio_handle(BYTE* buffer, int fd) {
-  HANDLE handle;
-  memcpy(&handle, CHILD_STDIO_HANDLE(buffer, fd), sizeof(HANDLE));
-  return handle;
+  return CHILD_STDIO_HANDLE(buffer, fd);
 }
diff --git a/deps/uv/src/win/process.c b/deps/uv/src/win/process.c
index 9d48ddc6f84..4e94dee90e1 100644
--- a/deps/uv/src/win/process.c
+++ b/deps/uv/src/win/process.c
@@ -26,6 +26,7 @@
 #include <signal.h>
 #include <limits.h>
 #include <wchar.h>
+#include <malloc.h>    /* _alloca */
 
 #include "uv.h"
 #include "internal.h"
@@ -597,9 +598,11 @@ error:
 }
 
 
-static int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
+int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
   wchar_t* a_eq;
   wchar_t* b_eq;
+  wchar_t* A;
+  wchar_t* B;
   int nb;
   int r;
 
@@ -614,8 +617,27 @@ static int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
   assert(b_eq);
   nb = b_eq - b;
 
-  r = CompareStringOrdinal(a, na, b, nb, /*case insensitive*/TRUE);
-  return r - CSTR_EQUAL;
+  A = _alloca((na+1) * sizeof(wchar_t));
+  B = _alloca((nb+1) * sizeof(wchar_t));
+
+  r = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, a, na, A, na);
+  assert(r==na);
+  A[na] = L'\0';
+  r = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, b, nb, B, nb);
+  assert(r==nb);
+  B[nb] = L'\0';
+
+  for (;;) {
+    wchar_t AA = *A++;
+    wchar_t BB = *B++;
+    if (AA < BB) {
+      return -1;
+    } else if (AA > BB) {
+      return 1;
+    } else if (!AA && !BB) {
+      return 0;
+    }
+  }
 }
 
 
@@ -654,7 +676,6 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   WCHAR* dst_copy;
   WCHAR** ptr_copy;
   WCHAR** env_copy;
-  char* p;
   size_t required_vars_value_len[ARRAY_SIZE(required_vars)];
 
   /* first pass: determine size in UTF-16 */
@@ -670,13 +691,11 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   }
 
   /* second pass: copy to UTF-16 environment block */
-  len = env_block_count * sizeof(WCHAR*);
-  p = uv__malloc(len + env_len * sizeof(WCHAR));
-  if (p == NULL) {
+  dst_copy = uv__malloc(env_len * sizeof(WCHAR));
+  if (dst_copy == NULL && env_len > 0) {
     return UV_ENOMEM;
   }
-  env_copy = (void*) &p[0];
-  dst_copy = (void*) &p[len];
+  env_copy = _alloca(env_block_count * sizeof(WCHAR*));
 
   ptr = dst_copy;
   ptr_copy = env_copy;
@@ -726,7 +745,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   /* final pass: copy, in sort order, and inserting required variables */
   dst = uv__malloc((1+env_len) * sizeof(WCHAR));
   if (!dst) {
-    uv__free(p);
+    uv__free(dst_copy);
     return UV_ENOMEM;
   }
 
@@ -771,7 +790,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   assert(env_len == (size_t) (ptr - dst));
   *ptr = L'\0';
 
-  uv__free(p);
+  uv__free(dst_copy);
   *dst_ptr = dst;
   return 0;
 }
@@ -1289,34 +1308,16 @@ static int uv__kill(HANDLE process_handle, int signum) {
       /* Unconditionally terminate the process. On Windows, killed processes
        * normally return 1. */
       int err;
-      DWORD status;
 
       if (TerminateProcess(process_handle, 1))
         return 0;
 
-      /* If the process already exited before TerminateProcess was called,
+      /* If the process already exited before TerminateProcess was called,.
        * TerminateProcess will fail with ERROR_ACCESS_DENIED. */
       err = GetLastError();
-      if (err == ERROR_ACCESS_DENIED) {
-        /* First check using GetExitCodeProcess() with status different from
-         * STILL_ACTIVE (259). This check can be set incorrectly by the process,
-         * though that is uncommon. */
-        if (GetExitCodeProcess(process_handle, &status) &&
-            status != STILL_ACTIVE) {
-          return UV_ESRCH;
-        }
-
-        /* But the process could have exited with code == STILL_ACTIVE, use then
-         * WaitForSingleObject with timeout zero. This is prone to a race
-         * condition as it could return WAIT_TIMEOUT because the handle might
-         * not have been signaled yet.That would result in returning the wrong
-         * error code here (UV_EACCES instead of UV_ESRCH), but we cannot fix
-         * the kernel synchronization issue that TerminateProcess is
-         * inconsistent with WaitForSingleObject with just the APIs available to
-         * us in user space. */
-        if (WaitForSingleObject(process_handle, 0) == WAIT_OBJECT_0) {
-          return UV_ESRCH;
-        }
+      if (err == ERROR_ACCESS_DENIED &&
+          WaitForSingleObject(process_handle, 0) == WAIT_OBJECT_0) {
+        return UV_ESRCH;
       }
 
       return uv_translate_sys_error(err);
@@ -1324,14 +1325,6 @@ static int uv__kill(HANDLE process_handle, int signum) {
 
     case 0: {
       /* Health check: is the process still alive? */
-      DWORD status;
-
-      if (!GetExitCodeProcess(process_handle, &status))
-        return uv_translate_sys_error(GetLastError());
-
-      if (status != STILL_ACTIVE)
-        return UV_ESRCH;
-
       switch (WaitForSingleObject(process_handle, 0)) {
         case WAIT_OBJECT_0:
           return UV_ESRCH;
diff --git a/deps/uv/src/win/req-inl.h b/deps/uv/src/win/req-inl.h
index cf16e8ba41f..9e2075906f5 100644
--- a/deps/uv/src/win/req-inl.h
+++ b/deps/uv/src/win/req-inl.h
@@ -53,16 +53,16 @@
   (uv__ntstatus_to_winsock_error(GET_REQ_STATUS((req))))
 
 
-#define REGISTER_HANDLE_REQ(loop, handle)                               \
+#define REGISTER_HANDLE_REQ(loop, handle, req)                          \
   do {                                                                  \
     INCREASE_ACTIVE_COUNT((loop), (handle));                            \
-    uv__req_register((loop));                                           \
+    uv__req_register((loop), (req));                                    \
   } while (0)
 
-#define UNREGISTER_HANDLE_REQ(loop, handle)                             \
+#define UNREGISTER_HANDLE_REQ(loop, handle, req)                        \
   do {                                                                  \
     DECREASE_ACTIVE_COUNT((loop), (handle));                            \
-    uv__req_unregister((loop));                                         \
+    uv__req_unregister((loop), (req));                                  \
   } while (0)
 
 
@@ -83,7 +83,7 @@
 
 
 INLINE static uv_req_t* uv__overlapped_to_req(OVERLAPPED* overlapped) {
-  return container_of(overlapped, uv_req_t, u.io.overlapped);
+  return CONTAINING_RECORD(overlapped, uv_req_t, u.io.overlapped);
 }
 
 
diff --git a/deps/uv/src/win/signal.c b/deps/uv/src/win/signal.c
index 85730b27b2b..8c79871b9bb 100644
--- a/deps/uv/src/win/signal.c
+++ b/deps/uv/src/win/signal.c
@@ -91,7 +91,7 @@ int uv__signal_dispatch(int signum) {
 
   for (handle = RB_NFIND(uv_signal_tree_s, &uv__signal_tree, &lookup);
        handle != NULL && handle->signum == signum;
-       handle = RB_NEXT(uv_signal_tree_s, handle)) {
+       handle = RB_NEXT(uv_signal_tree_s, &uv__signal_tree, handle)) {
     unsigned long previous = InterlockedExchange(
             (volatile LONG*) &handle->pending_signum, signum);
 
diff --git a/deps/uv/src/win/stream.c b/deps/uv/src/win/stream.c
index a53a10b0382..7bf9ca388cb 100644
--- a/deps/uv/src/win/stream.c
+++ b/deps/uv/src/win/stream.c
@@ -131,7 +131,7 @@ int uv_write(uv_write_t* req,
     case UV_NAMED_PIPE:
       err = uv__pipe_write(
           loop, req, (uv_pipe_t*) handle, bufs, nbufs, NULL, cb);
-      return uv_translate_write_sys_error(err);
+      break;
     case UV_TTY:
       err = uv__tty_write(loop, req, (uv_tty_t*) handle, bufs, nbufs, cb);
       break;
@@ -164,7 +164,7 @@ int uv_write2(uv_write_t* req,
 
   err = uv__pipe_write(
       loop, req, (uv_pipe_t*) handle, bufs, nbufs, send_handle, cb);
-  return uv_translate_write_sys_error(err);
+  return uv_translate_sys_error(err);
 }
 
 
@@ -216,7 +216,7 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb) {
   handle->flags &= ~UV_HANDLE_WRITABLE;
   handle->stream.conn.shutdown_req = req;
   handle->reqs_pending++;
-  REGISTER_HANDLE_REQ(loop, handle);
+  REGISTER_HANDLE_REQ(loop, handle, req);
 
   if (handle->stream.conn.write_reqs_pending == 0) {
     if (handle->type == UV_NAMED_PIPE)
diff --git a/deps/uv/src/win/tcp.c b/deps/uv/src/win/tcp.c
index c452c12e8f0..187f36e2a61 100644
--- a/deps/uv/src/win/tcp.c
+++ b/deps/uv/src/win/tcp.c
@@ -58,17 +58,11 @@ static int uv__tcp_keepalive(uv_tcp_t* handle, SOCKET socket, int enable, unsign
     return WSAGetLastError();
   }
 
-  if (!enable)
-    return 0;
-
-  if (delay < 1)
-    return UV_EINVAL;
-
-  if (setsockopt(socket,
-                 IPPROTO_TCP,
-                 TCP_KEEPALIVE,
-                 (const char*)&delay,
-                 sizeof delay) == -1) {
+  if (enable && setsockopt(socket,
+                           IPPROTO_TCP,
+                           TCP_KEEPALIVE,
+                           (const char*)&delay,
+                           sizeof delay) == -1) {
     return WSAGetLastError();
   }
 
@@ -212,7 +206,7 @@ void uv__process_tcp_shutdown_req(uv_loop_t* loop, uv_tcp_t* stream, uv_shutdown
   assert(stream->flags & UV_HANDLE_CONNECTION);
 
   stream->stream.conn.shutdown_req = NULL;
-  UNREGISTER_HANDLE_REQ(loop, stream);
+  UNREGISTER_HANDLE_REQ(loop, stream, req);
 
   err = 0;
   if (stream->flags & UV_HANDLE_CLOSING)
@@ -292,12 +286,6 @@ static int uv__tcp_try_bind(uv_tcp_t* handle,
   DWORD err;
   int r;
 
-  /* There is no SO_REUSEPORT on Windows, Windows only knows SO_REUSEADDR.
-   * so we just return an error directly when UV_TCP_REUSEPORT is requested
-   * for binding the socket. */
-  if (flags & UV_TCP_REUSEPORT)
-    return ERROR_NOT_SUPPORTED;
-
   if (handle->socket == INVALID_SOCKET) {
     SOCKET sock;
 
@@ -834,7 +822,7 @@ out:
   if (handle->delayed_error != 0) {
     /* Process the req without IOCP. */
     handle->reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     uv__insert_pending_req(loop, (uv_req_t*)req);
     return 0;
   }
@@ -850,12 +838,12 @@ out:
   if (UV_SUCCEEDED_WITHOUT_IOCP(success)) {
     /* Process the req without IOCP. */
     handle->reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     uv__insert_pending_req(loop, (uv_req_t*)req);
   } else if (UV_SUCCEEDED_WITH_IOCP(success)) {
     /* The req will be processed with IOCP. */
     handle->reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
   } else {
     return WSAGetLastError();
   }
@@ -925,14 +913,14 @@ int uv__tcp_write(uv_loop_t* loop,
     req->u.io.queued_bytes = 0;
     handle->reqs_pending++;
     handle->stream.conn.write_reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     uv__insert_pending_req(loop, (uv_req_t*) req);
   } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {
     /* Request queued by the kernel. */
     req->u.io.queued_bytes = uv__count_bufs(bufs, nbufs);
     handle->reqs_pending++;
     handle->stream.conn.write_reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     handle->write_queue_size += req->u.io.queued_bytes;
     if (handle->flags & UV_HANDLE_EMULATE_IOCP &&
         !RegisterWaitForSingleObject(&req->wait_handle,
@@ -946,7 +934,7 @@ int uv__tcp_write(uv_loop_t* loop,
     req->u.io.queued_bytes = 0;
     handle->reqs_pending++;
     handle->stream.conn.write_reqs_pending++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     SET_REQ_ERROR(req, WSAGetLastError());
     uv__insert_pending_req(loop, (uv_req_t*) req);
   }
@@ -1117,7 +1105,7 @@ void uv__process_tcp_write_req(uv_loop_t* loop, uv_tcp_t* handle,
   assert(handle->write_queue_size >= req->u.io.queued_bytes);
   handle->write_queue_size -= req->u.io.queued_bytes;
 
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   if (handle->flags & UV_HANDLE_EMULATE_IOCP) {
     if (req->wait_handle != INVALID_HANDLE_VALUE) {
@@ -1209,7 +1197,7 @@ void uv__process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,
 
   assert(handle->type == UV_TCP);
 
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   err = 0;
   if (handle->delayed_error) {
@@ -1563,6 +1551,11 @@ int uv__tcp_connect(uv_connect_t* req,
   return 0;
 }
 
+#ifndef WSA_FLAG_NO_HANDLE_INHERIT
+/* Added in Windows 7 SP1. Specify this to avoid race conditions, */
+/* but also manually clear the inherit flag in case this failed. */
+#define WSA_FLAG_NO_HANDLE_INHERIT 0x80
+#endif
 
 int uv_socketpair(int type, int protocol, uv_os_sock_t fds[2], int flags0, int flags1) {
   SOCKET server = INVALID_SOCKET;
diff --git a/deps/uv/src/win/thread.c b/deps/uv/src/win/thread.c
index bf39b88633b..57c25e8f5a8 100644
--- a/deps/uv/src/win/thread.c
+++ b/deps/uv/src/win/thread.c
@@ -32,23 +32,45 @@
 #include "uv.h"
 #include "internal.h"
 
-typedef void (*uv__once_cb)(void);
+static void uv__once_inner(uv_once_t* guard, void (*callback)(void)) {
+  DWORD result;
+  HANDLE existing_event, created_event;
+
+  created_event = CreateEvent(NULL, 1, 0, NULL);
+  if (created_event == 0) {
+    /* Could fail in a low-memory situation? */
+    uv_fatal_error(GetLastError(), "CreateEvent");
+  }
 
-typedef struct {
-  uv__once_cb callback;
-} uv__once_data_t;
+  existing_event = InterlockedCompareExchangePointer(&guard->event,
+                                                     created_event,
+                                                     NULL);
 
-static BOOL WINAPI uv__once_inner(INIT_ONCE *once, void* param, void** context) {
-  uv__once_data_t* data = param;
+  if (existing_event == NULL) {
+    /* We won the race */
+    callback();
 
-  data->callback();
+    result = SetEvent(created_event);
+    assert(result);
+    guard->ran = 1;
 
-  return TRUE;
+  } else {
+    /* We lost the race. Destroy the event we created and wait for the existing
+     * one to become signaled. */
+    CloseHandle(created_event);
+    result = WaitForSingleObject(existing_event, INFINITE);
+    assert(result == WAIT_OBJECT_0);
+  }
 }
 
-void uv_once(uv_once_t* guard, uv__once_cb callback) {
-  uv__once_data_t data = { .callback = callback };
-  InitOnceExecuteOnce(&guard->init_once, uv__once_inner, (void*) &data, NULL);
+
+void uv_once(uv_once_t* guard, void (*callback)(void)) {
+  /* Fast case - avoid WaitForSingleObject. */
+  if (guard->ran) {
+    return;
+  }
+
+  uv__once_inner(guard, callback);
 }
 
 
diff --git a/deps/uv/src/win/tty.c b/deps/uv/src/win/tty.c
index c0339ded2e4..9f8dd698d76 100644
--- a/deps/uv/src/win/tty.c
+++ b/deps/uv/src/win/tty.c
@@ -2183,7 +2183,7 @@ int uv__tty_write(uv_loop_t* loop,
 
   handle->reqs_pending++;
   handle->stream.conn.write_reqs_pending++;
-  REGISTER_HANDLE_REQ(loop, handle);
+  REGISTER_HANDLE_REQ(loop, handle, req);
 
   req->u.io.queued_bytes = 0;
 
@@ -2219,7 +2219,7 @@ void uv__process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,
   int err;
 
   handle->write_queue_size -= req->u.io.queued_bytes;
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   if (req->cb) {
     err = GET_REQ_ERROR(req);
@@ -2263,7 +2263,7 @@ void uv__process_tty_shutdown_req(uv_loop_t* loop, uv_tty_t* stream, uv_shutdown
   assert(req);
 
   stream->stream.conn.shutdown_req = NULL;
-  UNREGISTER_HANDLE_REQ(loop, stream);
+  UNREGISTER_HANDLE_REQ(loop, stream, req);
 
   /* TTY shutdown is really just a no-op */
   if (req->cb) {
@@ -2380,8 +2380,8 @@ static DWORD WINAPI uv__tty_console_resize_watcher_thread(void* param) {
     /* Make sure to not overwhelm the system with resize events */
     Sleep(33);
     WaitForSingleObject(uv__tty_console_resized, INFINITE);
-    ResetEvent(uv__tty_console_resized);
     uv__tty_console_signal_resize();
+    ResetEvent(uv__tty_console_resized);
   }
   return 0;
 }
diff --git a/deps/uv/src/win/udp.c b/deps/uv/src/win/udp.c
index 5c8f6e1dd0b..eab53842d4f 100644
--- a/deps/uv/src/win/udp.c
+++ b/deps/uv/src/win/udp.c
@@ -200,12 +200,6 @@ static int uv__udp_maybe_bind(uv_udp_t* handle,
   if (handle->flags & UV_HANDLE_BOUND)
     return 0;
 
-  /* There is no SO_REUSEPORT on Windows, Windows only knows SO_REUSEADDR.
-   * so we just return an error directly when UV_UDP_REUSEPORT is requested
-   * for binding the socket. */
-  if (flags & UV_UDP_REUSEPORT)
-    return ERROR_NOT_SUPPORTED;
-
   if ((flags & UV_UDP_IPV6ONLY) && addr->sa_family != AF_INET6) {
     /* UV_UDP_IPV6ONLY is supported only for IPV6 sockets */
     return ERROR_INVALID_PARAMETER;
@@ -382,7 +376,7 @@ static int uv__send(uv_udp_send_t* req,
     handle->reqs_pending++;
     handle->send_queue_size += req->u.io.queued_bytes;
     handle->send_queue_count++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
     uv__insert_pending_req(loop, (uv_req_t*)req);
   } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {
     /* Request queued by the kernel. */
@@ -390,7 +384,7 @@ static int uv__send(uv_udp_send_t* req,
     handle->reqs_pending++;
     handle->send_queue_size += req->u.io.queued_bytes;
     handle->send_queue_count++;
-    REGISTER_HANDLE_REQ(loop, handle);
+    REGISTER_HANDLE_REQ(loop, handle, req);
   } else {
     /* Send failed due to an error. */
     return WSAGetLastError();
@@ -533,7 +527,7 @@ void uv__process_udp_send_req(uv_loop_t* loop, uv_udp_t* handle,
   handle->send_queue_size -= req->u.io.queued_bytes;
   handle->send_queue_count--;
 
-  UNREGISTER_HANDLE_REQ(loop, handle);
+  UNREGISTER_HANDLE_REQ(loop, handle, req);
 
   if (req->cb) {
     err = 0;
diff --git a/deps/uv/src/win/util.c b/deps/uv/src/win/util.c
index e0dba1aaa94..a96cb915930 100644
--- a/deps/uv/src/win/util.c
+++ b/deps/uv/src/win/util.c
@@ -316,19 +316,25 @@ uv_pid_t uv_os_getpid(void) {
 
 
 uv_pid_t uv_os_getppid(void) {
-  NTSTATUS nt_status;
-  PROCESS_BASIC_INFORMATION basic_info;
-
-  nt_status = pNtQueryInformationProcess(GetCurrentProcess(),
-    ProcessBasicInformation,
-    &basic_info,
-    sizeof(basic_info),
-    NULL);
-  if (NT_SUCCESS(nt_status)) {
-    return basic_info.InheritedFromUniqueProcessId;
-  } else {
-    return -1;
+  int parent_pid = -1;
+  HANDLE handle;
+  PROCESSENTRY32 pe;
+  DWORD current_pid = GetCurrentProcessId();
+
+  pe.dwSize = sizeof(PROCESSENTRY32);
+  handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+
+  if (Process32First(handle, &pe)) {
+    do {
+      if (pe.th32ProcessID == current_pid) {
+        parent_pid = pe.th32ParentProcessID;
+        break;
+      }
+    } while( Process32Next(handle, &pe));
   }
+
+  CloseHandle(handle);
+  return parent_pid;
 }
 
 
@@ -506,23 +512,19 @@ int uv_uptime(double* uptime) {
 
 
 unsigned int uv_available_parallelism(void) {
-  DWORD_PTR procmask;
-  DWORD_PTR sysmask;
-  int count;
-  int i;
+  SYSTEM_INFO info;
+  unsigned rc;
 
   /* TODO(bnoordhuis) Use GetLogicalProcessorInformationEx() to support systems
    * with > 64 CPUs? See https://github.com/libuv/libuv/pull/3458
    */
-  count = 0;
-  if (GetProcessAffinityMask(GetCurrentProcess(), &procmask, &sysmask))
-    for (i = 0; i < 8 * sizeof(procmask); i++)
-      count += 1 & (procmask >> i);
+  GetSystemInfo(&info);
 
-  if (count > 0)
-    return count;
+  rc = info.dwNumberOfProcessors;
+  if (rc < 1)
+    rc = 1;
 
-  return 1;
+  return rc;
 }
 
 
@@ -940,13 +942,8 @@ int uv_os_homedir(char* buffer, size_t* size) {
   r = uv_os_getenv("USERPROFILE", buffer, size);
 
   /* Don't return an error if USERPROFILE was not found. */
-  if (r != UV_ENOENT) {
-    /* USERPROFILE is empty or invalid */
-    if (r == 0 && *size < 3) {
-      return UV_ENOENT;
-    }
+  if (r != UV_ENOENT)
     return r;
-  }
 
   /* USERPROFILE is not set, so call uv_os_get_passwd() */
   r = uv_os_get_passwd(&pwd);
@@ -983,12 +980,6 @@ int uv_os_tmpdir(char* buffer, size_t* size) {
   if (len == 0) {
     return uv_translate_sys_error(GetLastError());
   }
-
-  /* tmp path is empty or invalid */
-  if (len < 3) {
-    return UV_ENOENT;
-  }
-
   /* Include space for terminating null char. */
   len += 1;
   path = uv__malloc(len * sizeof(wchar_t));
@@ -1268,9 +1259,6 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {
     SetLastError(ERROR_SUCCESS);
     len = GetEnvironmentVariableW(name_w, var, varlen);
 
-    if (len == 0)
-      r = uv_translate_sys_error(GetLastError());
-
     if (len < varlen)
       break;
 
@@ -1292,8 +1280,15 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {
   uv__free(name_w);
   name_w = NULL;
 
-  if (r == 0)
-    r = uv__copy_utf16_to_utf8(var, len, buffer, size);
+  if (len == 0) {
+    r = GetLastError();
+    if (r != ERROR_SUCCESS) {
+      r = uv_translate_sys_error(r);
+      goto fail;
+    }
+  }
+
+  r = uv__copy_utf16_to_utf8(var, len, buffer, size);
 
 fail:
 
@@ -1533,7 +1528,20 @@ int uv_os_uname(uv_utsname_t* buffer) {
   os_info.dwOSVersionInfoSize = sizeof(os_info);
   os_info.szCSDVersion[0] = L'\0';
 
-  pRtlGetVersion(&os_info);
+  /* Try calling RtlGetVersion(), and fall back to the deprecated GetVersionEx()
+     if RtlGetVersion() is not available. */
+  if (pRtlGetVersion) {
+    pRtlGetVersion(&os_info);
+  } else {
+    /* Silence GetVersionEx() deprecation warning. */
+    #ifdef _MSC_VER
+    #pragma warning(suppress : 4996)
+    #endif
+    if (GetVersionExW(&os_info) == 0) {
+      r = uv_translate_sys_error(GetLastError());
+      goto error;
+    }
+  }
 
   /* Populate the version field. */
   version_size = 0;
diff --git a/deps/uv/src/win/winapi.c b/deps/uv/src/win/winapi.c
index a74108db03e..53147b8262e 100644
--- a/deps/uv/src/win/winapi.c
+++ b/deps/uv/src/win/winapi.c
@@ -48,16 +48,12 @@ sSetWinEventHook pSetWinEventHook;
 /* ws2_32.dll function pointer */
 uv_sGetHostNameW pGetHostNameW;
 
-/* api-ms-win-core-file-l2-1-4.dll function pointer */
-sGetFileInformationByName pGetFileInformationByName;
-
 void uv__winapi_init(void) {
   HMODULE ntdll_module;
   HMODULE powrprof_module;
   HMODULE user32_module;
   HMODULE kernel32_module;
   HMODULE ws2_32_module;
-  HMODULE api_win_core_file_module;
 
   ntdll_module = GetModuleHandleA("ntdll.dll");
   if (ntdll_module == NULL) {
@@ -103,7 +99,7 @@ void uv__winapi_init(void) {
 
   pNtQueryDirectoryFile = (sNtQueryDirectoryFile)
       GetProcAddress(ntdll_module, "NtQueryDirectoryFile");
-  if (pNtQueryDirectoryFile == NULL) {
+  if (pNtQueryVolumeInformationFile == NULL) {
     uv_fatal_error(GetLastError(), "GetProcAddress");
   }
 
@@ -148,10 +144,4 @@ void uv__winapi_init(void) {
         ws2_32_module,
         "GetHostNameW");
   }
-
-  api_win_core_file_module = GetModuleHandleA("api-ms-win-core-file-l2-1-4.dll");
-  if (api_win_core_file_module != NULL) {
-    pGetFileInformationByName = (sGetFileInformationByName)GetProcAddress(
-        api_win_core_file_module, "GetFileInformationByName");
-  }
 }
diff --git a/deps/uv/src/win/winapi.h b/deps/uv/src/win/winapi.h
index 548081f23a9..d380bda42a3 100644
--- a/deps/uv/src/win/winapi.h
+++ b/deps/uv/src/win/winapi.h
@@ -4125,24 +4125,6 @@ typedef const UNICODE_STRING *PCUNICODE_STRING;
 # define DEVICE_TYPE DWORD
 #endif
 
-typedef struct _FILE_STAT_BASIC_INFORMATION {
-  LARGE_INTEGER FileId;
-  LARGE_INTEGER CreationTime;
-  LARGE_INTEGER LastAccessTime;
-  LARGE_INTEGER LastWriteTime;
-  LARGE_INTEGER ChangeTime;
-  LARGE_INTEGER AllocationSize;
-  LARGE_INTEGER EndOfFile;
-  ULONG FileAttributes;
-  ULONG ReparseTag;
-  ULONG NumberOfLinks;
-  ULONG DeviceType;
-  ULONG DeviceCharacteristics;
-  ULONG Reserved;
-  FILE_ID_128 FileId128;
-  LARGE_INTEGER VolumeSerialNumber;
-} FILE_STAT_BASIC_INFORMATION;
-
 /* MinGW already has a definition for REPARSE_DATA_BUFFER, but mingw-w64 does
  * not.
  */
@@ -4242,15 +4224,6 @@ typedef enum _FILE_INFORMATION_CLASS {
   FileNumaNodeInformation,
   FileStandardLinkInformation,
   FileRemoteProtocolInformation,
-  FileRenameInformationBypassAccessCheck,
-  FileLinkInformationBypassAccessCheck,
-  FileVolumeNameInformation,
-  FileIdInformation,
-  FileIdExtdDirectoryInformation,
-  FileReplaceCompletionInformation,
-  FileHardLinkFullIdInformation,
-  FileIdExtdBothDirectoryInformation,
-  FileDispositionInformationEx, /* based on https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_file_information_class */
   FileMaximumInformation
 } FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
 
@@ -4350,10 +4323,6 @@ typedef struct _FILE_DISPOSITION_INFORMATION {
   BOOLEAN DeleteFile;
 } FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;
 
-typedef struct _FILE_DISPOSITION_INFORMATION_EX {
-  DWORD Flags;
-} FILE_DISPOSITION_INFORMATION_EX, *PFILE_DISPOSITION_INFORMATION_EX;
-
 typedef struct _FILE_PIPE_LOCAL_INFORMATION {
   ULONG NamedPipeType;
   ULONG NamedPipeConfiguration;
@@ -4458,14 +4427,6 @@ typedef struct _FILE_FS_SECTOR_SIZE_INFORMATION {
   ULONG ByteOffsetForPartitionAlignment;
 } FILE_FS_SECTOR_SIZE_INFORMATION, *PFILE_FS_SECTOR_SIZE_INFORMATION;
 
-typedef struct _PROCESS_BASIC_INFORMATION {
-  PVOID Reserved1;
-  PVOID PebBaseAddress;
-  PVOID Reserved2[2];
-  ULONG_PTR UniqueProcessId;
-  ULONG_PTR InheritedFromUniqueProcessId;
-} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;
-
 typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
     LARGE_INTEGER IdleTime;
     LARGE_INTEGER KernelTime;
@@ -4479,10 +4440,6 @@ typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
 # define SystemProcessorPerformanceInformation 8
 #endif
 
-#ifndef ProcessBasicInformation
-# define ProcessBasicInformation 0
-#endif
-
 #ifndef ProcessConsoleHostProcess
 # define ProcessConsoleHostProcess 49
 #endif
@@ -4782,21 +4739,6 @@ typedef struct _TCP_INITIAL_RTO_PARAMETERS {
 # define  SIO_TCP_INITIAL_RTO _WSAIOW(IOC_VENDOR,17)
 #endif
 
-/* from winnt.h */
-typedef enum _FILE_INFO_BY_NAME_CLASS {
-  FileStatByNameInfo,
-  FileStatLxByNameInfo,
-  FileCaseSensitiveByNameInfo,
-  FileStatBasicByNameInfo,
-  MaximumFileInfoByNameClass
-} FILE_INFO_BY_NAME_CLASS;
-
-typedef BOOL(WINAPI* sGetFileInformationByName)(
-    PCWSTR FileName,
-    FILE_INFO_BY_NAME_CLASS FileInformationClass,
-    PVOID FileInfoBuffer,
-    ULONG FileInfoBufferSize);
-
 /* Ntdll function pointers */
 extern sRtlGetVersion pRtlGetVersion;
 extern sRtlNtStatusToDosError pRtlNtStatusToDosError;
@@ -4817,9 +4759,6 @@ extern sPowerRegisterSuspendResumeNotification pPowerRegisterSuspendResumeNotifi
 /* User32.dll function pointer */
 extern sSetWinEventHook pSetWinEventHook;
 
-/* api-ms-win-core-file-l2-1-4.dll function pointers */
-extern sGetFileInformationByName pGetFileInformationByName;
-
 /* ws2_32.dll function pointer */
 /* mingw doesn't have this definition, so let's declare it here locally */
 typedef int (WINAPI *uv_sGetHostNameW)
diff --git a/deps/uv/uv.gyp b/deps/uv/uv.gyp
index fea86b4af78..6c86c3fa504 100644
--- a/deps/uv/uv.gyp
+++ b/deps/uv/uv.gyp
@@ -124,7 +124,6 @@
     'uv_sources_apple': [
       'src/unix/darwin.c',
       'src/unix/fsevents.c',
-      'src/unix/darwin-syscalls.h',
       'src/unix/darwin-proctitle.c',
       'src/unix/random-getentropy.c',
     ],
